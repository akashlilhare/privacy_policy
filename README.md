
<!-- Output copied to clipboard! -->

<!-----

You have some errors, warnings, or alerts. If you are using reckless mode, turn it off to see inline alerts.
* ERRORs: 0
* WARNINGs: 0
* ALERTS: 89

Conversion time: 31.127 seconds.


Using this Markdown file:

1. Paste this output into your source file.
2. See the notes and action items below regarding this conversion run.
3. Check the rendered output (headings, lists, code blocks, tables) for proper
   formatting and use a linkchecker before you publish this page.

Conversion notes:

* Docs to Markdown version 1.0β33
* Mon Jan 17 2022 15:50:32 GMT-0800 (PST)
* Source doc: DBMS
* Tables are currently converted to HTML tables.
* This document has images: check for >>>>>  gd2md-html alert:  inline image link in generated source and store images to your server. NOTE: Images in exported zip file from Google Docs may not appear in  the same order as they do in your doc. Please check the images!


WARNING:
You have 5 H1 headings. You may want to use the "H1 -> H2" option to demote all headings by one level.

----->


<p style="color: red; font-weight: bold">>>>>>  gd2md-html alert:  ERRORs: 0; WARNINGs: 1; ALERTS: 89.</p>
<ul style="color: red; font-weight: bold"><li>See top comment block for details on ERRORs and WARNINGs. <li>In the converted Markdown or HTML, search for inline alerts that start with >>>>>  gd2md-html alert:  for specific instances that need correction.</ul>

<p style="color: red; font-weight: bold">Links to alert messages:</p><a href="#gdcalert1">alert1</a>
<a href="#gdcalert2">alert2</a>
<a href="#gdcalert3">alert3</a>
<a href="#gdcalert4">alert4</a>
<a href="#gdcalert5">alert5</a>
<a href="#gdcalert6">alert6</a>
<a href="#gdcalert7">alert7</a>
<a href="#gdcalert8">alert8</a>
<a href="#gdcalert9">alert9</a>
<a href="#gdcalert10">alert10</a>
<a href="#gdcalert11">alert11</a>
<a href="#gdcalert12">alert12</a>
<a href="#gdcalert13">alert13</a>
<a href="#gdcalert14">alert14</a>
<a href="#gdcalert15">alert15</a>
<a href="#gdcalert16">alert16</a>
<a href="#gdcalert17">alert17</a>
<a href="#gdcalert18">alert18</a>
<a href="#gdcalert19">alert19</a>
<a href="#gdcalert20">alert20</a>
<a href="#gdcalert21">alert21</a>
<a href="#gdcalert22">alert22</a>
<a href="#gdcalert23">alert23</a>
<a href="#gdcalert24">alert24</a>
<a href="#gdcalert25">alert25</a>
<a href="#gdcalert26">alert26</a>
<a href="#gdcalert27">alert27</a>
<a href="#gdcalert28">alert28</a>
<a href="#gdcalert29">alert29</a>
<a href="#gdcalert30">alert30</a>
<a href="#gdcalert31">alert31</a>
<a href="#gdcalert32">alert32</a>
<a href="#gdcalert33">alert33</a>
<a href="#gdcalert34">alert34</a>
<a href="#gdcalert35">alert35</a>
<a href="#gdcalert36">alert36</a>
<a href="#gdcalert37">alert37</a>
<a href="#gdcalert38">alert38</a>
<a href="#gdcalert39">alert39</a>
<a href="#gdcalert40">alert40</a>
<a href="#gdcalert41">alert41</a>
<a href="#gdcalert42">alert42</a>
<a href="#gdcalert43">alert43</a>
<a href="#gdcalert44">alert44</a>
<a href="#gdcalert45">alert45</a>
<a href="#gdcalert46">alert46</a>
<a href="#gdcalert47">alert47</a>
<a href="#gdcalert48">alert48</a>
<a href="#gdcalert49">alert49</a>
<a href="#gdcalert50">alert50</a>
<a href="#gdcalert51">alert51</a>
<a href="#gdcalert52">alert52</a>
<a href="#gdcalert53">alert53</a>
<a href="#gdcalert54">alert54</a>
<a href="#gdcalert55">alert55</a>
<a href="#gdcalert56">alert56</a>
<a href="#gdcalert57">alert57</a>
<a href="#gdcalert58">alert58</a>
<a href="#gdcalert59">alert59</a>
<a href="#gdcalert60">alert60</a>
<a href="#gdcalert61">alert61</a>
<a href="#gdcalert62">alert62</a>
<a href="#gdcalert63">alert63</a>
<a href="#gdcalert64">alert64</a>
<a href="#gdcalert65">alert65</a>
<a href="#gdcalert66">alert66</a>
<a href="#gdcalert67">alert67</a>
<a href="#gdcalert68">alert68</a>
<a href="#gdcalert69">alert69</a>
<a href="#gdcalert70">alert70</a>
<a href="#gdcalert71">alert71</a>
<a href="#gdcalert72">alert72</a>
<a href="#gdcalert73">alert73</a>
<a href="#gdcalert74">alert74</a>
<a href="#gdcalert75">alert75</a>
<a href="#gdcalert76">alert76</a>
<a href="#gdcalert77">alert77</a>
<a href="#gdcalert78">alert78</a>
<a href="#gdcalert79">alert79</a>
<a href="#gdcalert80">alert80</a>
<a href="#gdcalert81">alert81</a>
<a href="#gdcalert82">alert82</a>
<a href="#gdcalert83">alert83</a>
<a href="#gdcalert84">alert84</a>
<a href="#gdcalert85">alert85</a>
<a href="#gdcalert86">alert86</a>
<a href="#gdcalert87">alert87</a>
<a href="#gdcalert88">alert88</a>
<a href="#gdcalert89">alert89</a>

<p style="color: red; font-weight: bold">>>>>> PLEASE check and correct alert issues and delete this message and the inline alerts.<hr></p>



## Scaling


### Types of Scaling:



1. **Vertical Scaling : **

    When new resources are added to the existing system to meet the expectation, it is known as vertical scaling. Consider a rack of servers and resources that comprises the existing system. Now when the existing system fails to meet the expected needs, and the expected needs can be met by just adding resources, this is considered as vertical scaling.


    Vertical scaling is not only easy but also cheaper than Horizontal Scaling. It also requires less time to be fixed.

2. **Horizontal Scaling: **

    When new server racks are added to the existing system to meet the higher expectation, it is known as horizontal scaling. Consider a rack of servers and resources that comprises the existing system. Now when the existing system fails to meet the expected needs, and the expected needs cannot be met by just adding resources, we need to add completely new servers. This is considered horizontal scaling.


    Horizontal scaling is difficult and also costlier than Vertical Scaling. It also requires more time to be fixed.


<table>
  <tr>
   <td>
<strong>Horizontal Scaling</strong>
   </td>
   <td><strong>Vertical Scaling</strong>
   </td>
  </tr>
  <tr>
   <td>When new server racks are added to the existing system to meet the higher expectation, it is known as horizontal scaling.
   </td>
   <td>When new resources are added to the existing system to meet the expectation, it is known as vertical scaling
   </td>
  </tr>
  <tr>
   <td>It expands the size of the existing system horizontally.
   </td>
   <td>It expands the size of the existing system vertically.
   </td>
  </tr>
  <tr>
   <td>It is difficult to implement
   </td>
   <td>It is easy to implement
   </td>
  </tr>
  <tr>
   <td>It is costlier, as new server racks comprise a lot of resources
   </td>
   <td>It is cheaper as we need to just add new resources
   </td>
  </tr>
  <tr>
   <td>It takes more time to be done
   </td>
   <td>It takes less time to be done
   </td>
  </tr>
</table>



## Hashing

In computing, a cache is a high-speed data storage layer that stores a subset of data, typically transient, so that future requests for that data are served up faster than is possible by accessing the data’s primary storage location. Caching allows you to efficiently reuse previously retrieved or computed data.

The data in a cache is generally stored in fast access hardware such as RAM (Random-access memory) Due to the high request rates or IOPS (Input/Output operations per second) supported by RAM and In-Memory engines, caching results in improved data retrieval performance and reduces cost at scale.

**Applications**: Caches can be applied and leveraged throughout various layers of technology including Operating Systems, Networking layers including Content Delivery Networks (CDN) and DNS, web applications, and Databases. You can use caching to significantly reduce latency and improve IOPS for many read-heavy application workloads, such as Q&A portals, gaming, media sharing, and social networking.


## Load Balancer

Load Balancer (LB) is a critical component of any distributed system. It helps to spread the traffic across a cluster of servers to improve responsiveness and availability of applications, websites or databases. LB also keeps track of the status of all the resources while distributing requests. If a server is not available to take new requests or is not responding or has an elevated error rate, LB will stop sending traffic to such a server.

Typically a load balancer sits between the client and the server accepting incoming network and application traffic and distributing the traffic across multiple backend servers using various algorithms. By balancing application requests across multiple servers, a load balancer reduces individual server load and prevents any one application server from becoming a single point of failure, thus improving overall application availability and responsiveness.


# Database


## What is Data?

Data is a collection of a distinct small unit of information. It can be used in a variety of forms like text, numbers, media, bytes, etc. it can be stored in pieces of paper or electronic memory, etc.


## What is Database?



* A database is an organized collection of data so that it can be easily accessed and managed. We can organize data into tables, rows, columns, and index it to make it easier to find relevant information.
* There are many databases available like MySQL, Sybase, Oracle, MongoDB, Informix, PostgreSQL, SQL Server, etc.

	


## What is DBMS?

**Database Management System (DBMS)** is software for storing and retrieving users' data while considering appropriate security measures. It consists of a group of programs that manipulate the database. The DBMS accepts the request for data from an application and instructs the operating system to provide the specific data. In large systems, a DBMS helps users and other third-party software to store and retrieve data.


### Characteristics of Database Management System



* Provides security and removes redundancy
* Self-describing nature of a database system
* Insulation between programs and data abstraction
* Support of multiple views of the data
* Sharing of data and multi-user transaction processing
* DBMS allows entities and relations among them to form tables.
* It follows the ACID concept ( Atomicity, Consistency, Isolation, and Durability).
* DBMS supports a multi-user environment that allows users to access and manipulate data in parallel.


## Types of DBMS



1. **Hierarchical DBMS**

### 
    In a Hierarchical database, model data is organized in a tree-like structure. Data is Stored Hierarchically (top-down or bottom-up) format. Data is represented using a parent-child relationship. In Hierarchical DBMS parents may have many children, but children have only one parent.

2. **Network Model**

    The network database model allows each child to have multiple parents. It helps you to address the need to model more complex relationships like the orders/parts many-to-many relationship. In this model, entities are organized in a graph which can be accessed through several paths.

3. **Relational Model**

	


    Relational DBMS is the most widely used DBMS model because it is one of the easiest. This model is based on normalizing data in the rows and columns of the tables. Relational model stored in fixed structures and manipulated using SQL.



4. **Object-Oriented Model**

    In Object-oriented Model data stored in the form of objects. The structure is called classes which display data within it. It defines a database as a collection of objects which stores both data members values and operations.



## DBMS vs File System


<table>
  <tr>
   <td><strong>DBMS</strong>
   </td>
   <td><strong>File System</strong>
   </td>
  </tr>
  <tr>
   <td>DBMS is a collection of data. In DBMS, the user is not required to write the procedures.
   </td>
   <td>File system is a collection of data. In this system, the user has to write the procedures for managing the database.
   </td>
  </tr>
  <tr>
   <td>DBMS gives an abstract view of data that hides the details.
   </td>
   <td>File system provides the detail of the data representation and storage of data.
   </td>
  </tr>
  <tr>
   <td>DBMS provides a crash recovery mechanism, i.e., DBMS protects the user from system failure.
   </td>
   <td>File system doesn't have a crash mechanism, i.e., if the system crashes while entering some data, then the content of the file will lose.
   </td>
  </tr>
  <tr>
   <td>DBMS provides a good protection mechanism.
   </td>
   <td>It is very difficult to protect a file under the file system.
   </td>
  </tr>
  <tr>
   <td>DBMS contains a wide variety of sophisticated techniques to store and retrieve the data.
   </td>
   <td>File system can't efficiently store and retrieve the data.
   </td>
  </tr>
  <tr>
   <td>DBMS takes care of Concurrent access of data using some form of locking.
   </td>
   <td>In the File system, concurrent access has many problems like redirecting the file while others deleting some information or updating some information.
   </td>
  </tr>
</table>



## What is Database Admin & its Functions?

**DBA stands for Database Administrators. **DBA is used for specialized software to store and organize data. The role may include capacity planning, installation, configuration, database design, migration, performance monitoring, security, troubleshooting, as well as backup and data recovery.

 **Database administration** is more of an operational or technical level function responsible for physical database design, security enforcement, and database performance.  Tasks include maintaining the data dictionary, monitoring performance, and enforcing organizational standards and security

These are the function of DBA:

1. Data policies, procedures, standards.

2. Planning- development of organization's IT strategy, enterprise model, cost/benefit model, design of database environment, and administration plan.

3. Data conflict (ownership) resolution.

4. Data analysis- Define and model data requirements, business rules, operational requirements, and maintain corporate data dictionary.

5. Internal marketing of DA concepts.

6. Managing the data repository.


## Database Tier-2/ Tier-3 Architecture

**1. Two-Tier Database Architecture –**

In two-tier, the application logic is either buried inside the User Interface on the client or within the database on the server (or both). With two-tier client/server architectures, the user system interface is usually located in the user’s desktop environment and the database management services are usually in a server that is a more powerful machine that services many clients.

**2. Three-Tier Database Architecture –**

In the three-tier, the application logic or process lives in the middle-tier, it is separated from the data and the user interface. Three-tier systems are more scalable, robust and flexible. Also, they can integrate data from multiple sources. A middle tier was added in the three-tier architecture between the user system interface client environment and the database management server environment. There are a variety of ways of implementing this middle tier, such as transaction processing monitors, message servers, or application servers.

**Difference Between Two-Tier And Three-Tier Database Architecture**


<table>
  <tr>
   <td><strong>S.NO</strong>
   </td>
   <td><strong>Two-Tier Database Architecture</strong>
   </td>
   <td><strong>Three-Tier Database Architecture</strong>
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>It is a Client-Server Architecture.
   </td>
   <td>It is a Web-based application.
   </td>
  </tr>
  <tr>
   <td>2
   </td>
   <td>In two-tier, the application logic is either buried inside the user interface on the client or within the database on the server (or both).
   </td>
   <td>In the three-tier, the application logic or process resides in the middle-tier, it is separated from the data and the user interface.
   </td>
  </tr>
  <tr>
   <td>3
   </td>
   <td>Two-tier architecture consists of two layers: Client Tier and Database (Data Tier).
   </td>
   <td>Three-tier architecture consists of three layers: Client Layer, Business Layer and Data Layer.
   </td>
  </tr>
  <tr>
   <td>4
   </td>
   <td>It is easy to build and maintain.
   </td>
   <td>It is complex to build and maintain.
   </td>
  </tr>
  <tr>
   <td>5
   </td>
   <td>Two-tier architecture runs slower.
   </td>
   <td>Three-tier architecture runs faster.
   </td>
  </tr>
  <tr>
   <td>6
   </td>
   <td>It is less secure as a client can communicate with the database directly.
   </td>
   <td>It is secured as the client is not allowed to communicate with the database directly.
   </td>
  </tr>
  <tr>
   <td>7
   </td>
   <td>It results in performance loss whenever the users increase rapidly.
   </td>
   <td>It results in performance loss whenever the system is run on the Internet but gives more performance than two-tier architecture.
   </td>
  </tr>
  <tr>
   <td>8
   </td>
   <td>Example – Contact Management System created using MS-Access or Railway Reservation System, etc.
   </td>
   <td>Example – Designing registration form which contains a text box, label, button or a large website on the Internet, etc.
   </td>
  </tr>
</table>



## Database Languages

**_Structured Query Language (SQL) is also known as Database Language_**



1. **DDL(Data Definition Language)**: DDL or Data Definition Language consists of the SQL commands that can be used to define the database schema. It simply deals with descriptions of the database schema and is used to create and modify the structure of database objects in the database. 

**Examples:**



* **CREATE **– is used to create the database or its objects (like table, index, function, views, store procedure and triggers).
* **DROP **– is used to delete objects from the database.
* **ALTER **-is used to alter the structure of the database.
* **TRUNCATE **– is used to remove all records from a table, including all spaces allocated for the records are removed.
* **COMMENT **– is used to add comments to the data dictionary.
* **RENAME **– is used to rename an object existing in the database.
2. **DML(Data Manipulation Language): **The SQL commands that deal with the manipulation of data present in the database belong to DML or Data Manipulation Language and this includes most of the SQL statements.

    **Examples of DML :**

* **INSERT **– is used to insert data into a table.
* **UPDATE **– is used to update existing data within a table.
* **DELETE **– is used to delete records from a database table.
3. **DCL(Data Control Language):** DCL includes commands such as GRANT and REVOKE which mainly deal with the rights, permissions and other controls of the database system. 

**Examples of DCL commands**: 



* **GRANT **- gives user’s access privileges to the database.
* **REVOKE **- withdraw user’s access privileges given by using the GRANT command.



<p id="gdcalert1" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image1.jpg). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert2">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image1.jpg "image_tooltip")



## Important Terms :

**Schema in DBMS **

A database schema is the skeleton structure that represents the logical view of the entire database. It defines how the data is organized and how the relations among them are associated. It formulates all the constraints that are to be applied to the data.

A database schema defines its entities and the relationship among them. It contains a descriptive detail of the database, which can be depicted using schema diagrams. The database designers design the schema to help programmers understand the database and make it useful.



<p id="gdcalert2" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image2.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert3">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image2.png "image_tooltip")


A database schema can be divided broadly into two categories −



* **Physical Database Schema** − This schema pertains to the actual storage of data and its form of storage like files, indices, etc. It defines how the data will be stored in secondary storage.
* **Logical Database Schema** − This schema defines all the logical constraints that need to be applied to the data stored. It defines tables, views, and integrity constraints.

**Instances in DBMS** 

We must distinguish these two terms individually. Database schema is the skeleton of a database. It is designed when the database doesn't exist at all. Once the database is operational, it is very difficult to make any changes to it. A database schema does not contain any data or information.

A database instance is a state of operational database with data at any given time. It contains a snapshot of the database. Database instances tend to change with time. A DBMS ensures that every instance (state) is in a valid state, by diligently following all the validations, constraints, and conditions that the database designers have imposed.

**Sub Schema in DBMS**: It can be defined as the subset or sub-level of a schema that has the same properties as the schema. In simple words, it is just an effective plan or the schema for the view. Well, it is interesting to note that it provides the users with a window through which the user can view only that part of the database which is of matter of interest to him. It Identifies a subset of areas, sets, records, data names defined in a database that is of interest to him. Thus a portion of the database can be seen by application programs and different application programs have different views of data.


## Data Abstraction in DBMS

Data Abstraction refers to the process of hiding irrelevant details from the user. So, what is the meaning of irrelevant details? Let's understand this with one example. Example: If we want to access any mail from our Gmail then we don't know where that data is physically stored i.e is the data present in India or USA or what data model has been used to store that data? We are not concerned about these things. We are only concerned with our email. So, information like these i.e. location of data and data models are irrelevant to us and in data abstraction, we do this only. Apart from the location of data and data models, there are other factors that we don't care about. We hide the unnecessary data from the user and this process of **hiding unwanted data is called Data Abstraction**.


## Three Levels of Data Abstraction:

There are mainly three levels of data abstraction and we divide them into three levels to achieve Data Independence. Data Independence means users and data should not directly interact with each other. The user should be at a different level and the data should be present at some other level. By doing so, Data Independence can be achieved. So, let's see in details what are these three levels of data abstraction:



<p id="gdcalert3" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image3.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert4">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image3.png "image_tooltip")




1. **View Level or External Schema: **

This level tells the application about how the data should be shown to the user. **_Example_**: If we have a login-id and password in a university system, then as a student, we can view our marks, attendance, fee structure, etc. But the faculty of the university will have a different view. He will have options like salary, edit marks of a student, enter attendance of the students, etc. So, both the student and the faculty have a different view. By doing so, the security of the system also increases. In this example, the student can't edit his marks but the faculty who is authorized to edit the marks can edit the student's marks. Similarly, the dean of the college or university will have some more authorization and accordingly, he will have his view. So, different users will have a different view according to the authorization they have.



2. **Conceptual Level or Logical Level**

This level tells how the data is stored and structured. We have different data models by which we can store the data. **_Example_**: Let us take an example where we use the relational model for storing the data. We have to store a student’s data, the columns in the student table will be student_name, age, mail_id, roll_no, etc. We have to define all these at this level while we are creating the database. Though the data is stored in the database the structure of the tables like the student table, teacher table, books table, etc is defined here in the conceptual level or logical level. Also, how the tables are related to each other are defined here. Overall, we can say that we are creating a blueprint of the data at the conceptual level.



3. **Physical Level or Internal Schema**

As the name suggests, the Physical level tells us where the data is stored i.e. it tells the actual location of the data that is being stored by the user. The Database Administrators(DBA) decide which data should be kept at which particular disk drive, how the data has to be fragmented, where it has to be stored etc. They decide if the data has to be centralized or distributed. Though we see the data in the form of tables at view level the data here is stored in the form of files only. It depends on the DBA, how he/she manages the database at the physical level.


# RDBMS

Let's start by defining some common terminology. A database management system (DBMS) is the software that controls the storage, retrieval, deletion, security, and integrity of data within a database. An RDBMS is a DBMS that manages a relational database. A relational database stores data in tables. Tables are organized into columns, and each column stores one type of data (integer, real number, character strings, date, …). The data for a single “instance” of a table is stored as a row. For example, the Customer table would have columns such as CustomerNumber, FirstName, and Surname, and a row within that table would be something like _{1701, “James”, “Kirk”}._

Tables typically have keys, one or more columns that uniquely identify a row within the table, in the case of the Customer table the key would be CustomerNumber. To improve access time to a data table you define an index on the table. An index provides a quick way to lookup data based on one or more columns in the table, just like the index of a book enables you to find specific information quickly.

**[E.F. Codd Rules](https://www.geeksforgeeks.org/introduction-of-relational-model-and-codd-rules-in-dbms/)**


## Keys in RDBMS

[Important question](https://www.geeksforgeeks.org/number-of-possible-superkeys-in-dbms/#:~:text=In%20general%2C%20if%20we%20have,keys%20%3D%202n%20%E2%80%93%201.)



<p id="gdcalert4" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image4.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert5">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image4.png "image_tooltip")


**Candidate Key**: The minimal set of attributes that can uniquely identify a tuple is known as a candidate key. For Example, STUD_NO in STUDENT relation. 



* The value of Candidate Key is unique and non-null for every tuple.
* There can be more than one candidate key in a relation. For Example, STUD_NO is a candidate key for relation STUDENT.
* The candidate key can be simple (having only one attribute) or composite as well. For Example, _{STUD_NO, COURSE_NO}_ is a composite candidate key for relation STUDENT_COURSE.
* No of candidate keys in a Relation are nC(floor(n/2)),for example if a Relation have 5 attribute i.e. R(A,B,C,D,E) then total no of candidate keys are 5C(floor(5/2))=10.
* **Note **– In SQL Server a unique constraint that has a nullable column, **allows **the value **‘null‘ **in that column** only once.** That’s why STUD_PHONE attribute is a candidate here, but can not be ‘null’ values in the primary key attribute.

     


**Super Key**: The set of attributes that can uniquely identify a tuple is known as Super Key. For Example, _STUD_NO, (STUD_NO, STUD_NAME)_ etc. 

 



* Adding zero or more attributes to candidate keys generates super keys.
* A candidate key is a super key but vice versa is not true.

**Primary Key**: There can be more than one candidate key in relation out of which one can be chosen as the primary key. For Example, STUD_NO, as well as STUD_PHONE both, are candidate keys for relation STUDENT but STUD_NO can be chosen as the primary key (only one out of many candidate keys). 

**Alternate Key**: The candidate key other than the primary key is called an alternate key. For Example, STUD_NO, as well as STUD_PHONE both, are candidate keys for relation STUDENT but STUD_PHONE will be an alternate key (only one out of many candidate keys). 

**Foreign Key**:

([Important Video](https://www.youtube.com/watch?v=DM2lAomoDrg&list=PLxCzCOWd7aiFAN6I8CuViBuCdJgiOkT2Y&index=11) on Foreign key**)**

If an attribute can only take the values which are present as values of some other attribute, it will be a foreign key to the attribute to which it refers. The relation which is being referenced is called referenced relation and the corresponding attribute is called referenced attribute and the relation which refers to the referenced relation is called referencing relation and the corresponding attribute is called referencing attribute. The referenced attribute of the referenced relation should be the primary key for it. For Example, _STUD_NO in STUDENT_COURSE is a foreign key to STUD_NO in STUDENT_ relation. 

It may be worth noting that unlike, Primary Key of any given relation, Foreign Key can be NULL as well as may contain duplicate tuples i.e. it need not follow uniqueness constraint. 

For Example,_ STUD_NO in STUDENT_COURSE_ relation is not unique. It has been repeated for the first and third tuple. However, the _STUD_NO in STUDENT_ relation is a primary key and it needs to be always unique and it cannot be null. 

**Referential Integrity: **To allow join, the referential integrity rule states that the Primary Key and Foreign Key have the same data types.


## Introduction of ER Model

ER Model is used to model the logical view of the system from a data perspective which consists of these components:

**Entity, Entity Type, Entity Set –**

An Entity may be an object with a physical existence – a particular person, car, house, or employee – or it may be an object with a conceptual existence – a company, a job, or a university course.

An Entity is an object of Entity Type and the set of all entities is called an entity set. e.g.; E1 is an entity having Entity Type Student and the set of all students is called Entity Set. In ER diagram, Entity Type is represented as:  



<p id="gdcalert5" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image5.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert6">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image5.png "image_tooltip")


**Attribute(s):**

Attributes are the properties that define the entity type. For example, Roll_No, Name, DOB, Age, Address, Mobile_No are the attributes that define entity type Student. In the ER diagram, the attribute is represented by an oval.



<p id="gdcalert6" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image6.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert7">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image6.png "image_tooltip")




1. **Key Attribute –**

    The attribute which uniquely identifies each entity in the entity set is called key attribute. For example, Roll_No will be unique for each student. In the ER diagram, key attribute is represented by an oval with underlying lines.


                            

<p id="gdcalert7" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image7.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert8">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image7.png "image_tooltip")


2. **Composite Attribute –**

    An attribute composed of many other attributes is called a composite attribute. For example, Address attribute of student Entity type consists of Street, City, State, and Country. In ER diagram, composite attribute is represented by an oval consisting of ovals.


    

<p id="gdcalert8" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image8.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert9">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image8.png "image_tooltip")


3. **Multivalued Attribute –**

    An attribute consisting of more than one value for a given entity. For example, Phone_No (can be more than one for a given student). In the ER diagram, multivalued attribute is represented by double oval.


    

<p id="gdcalert9" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image9.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert10">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image9.png "image_tooltip")


4. **Derived Attribute –**

    An attribute that can be derived from other attributes of the entity type is known as derived attribute. e.g.; Age (can be derived from DOB). In ER diagram, the derived attribute is represented by a dashed oval.


                     

<p id="gdcalert10" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image10.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert11">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image10.png "image_tooltip")



    The complete entity type** Student** with its attributes can be represented as:



<p id="gdcalert11" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image11.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert12">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image11.png "image_tooltip")


**Relationship Type and Relationship Set:**

A relationship type represents the **association between entity types**. For example, ‘Enrolled in’ is a relationship type that exists between entity type Student and Course. In ER diagram, the relationship type is represented by a diamond and connecting the entities with lines.



<p id="gdcalert12" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image12.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert13">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image12.png "image_tooltip")


A set of relationships of the same type is known as a relationship set. The following relationship set depicts S1 is enrolled in C2, S2 is enrolled in C1 and S3 is enrolled in C3.



<p id="gdcalert13" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image13.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert14">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image13.png "image_tooltip")



## Degree of Relations ER Model

There are three types of relationships that can exist between two entities.



1. **one-to-one relationship**: In relational database design, a one-to-one (1:1) relationship exists when zero or one instance of entity A can be associated with zero or one instance of entity B, and zero or one instance of entity B can be associated with zero or one instance of entity A. (abbreviated 1:1)
2. **one-to-many relationship:** (abbreviated 1:N) In relational database design, a one-to-many (1:N) relationship exists when, for one instance of entity A, there exists zero, one, or many instances of entity B; but for one instance of entity B, there exists zero or one instance of entity A.
3. **many-to-many relationship:** In relational database design, a many-to-many (M: N) relationship exists when, for one instance of entity A, there exists zero, one, or many instances of entity B; and for one instance of entity B, there exists zero, one, or many instances of entity A. (abbreviated M: N)

Following are simple examples of each:


<table>
  <tr>
   <td>1:1 relationship
   </td>
   <td>In a traditional American marriage, a man can be married to only one woman; a woman can be married to only one man.
   </td>
  </tr>
  <tr>
   <td>1:N relationship
   </td>
   <td>A child has exactly one biological father; a father can have many biological children.
   </td>
  </tr>
  <tr>
   <td>M: the N relationship
   </td>
   <td>A student can enrol in many classes; a class can have many enrolled students.
   </td>
  </tr>
</table>


**1) One To One**



<p id="gdcalert14" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image14.jpg). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert15">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image14.jpg "image_tooltip")


_An employee can work in at most one department, and a department can have at most one employee._

**2) One To Many**



<p id="gdcalert15" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image15.jpg). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert16">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image15.jpg "image_tooltip")


_An employee can work in many departments (>=0), but a department can have at most one employee._

**3) Many To One**



<p id="gdcalert16" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image16.jpg). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert17">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image16.jpg "image_tooltip")


_An employee can work in at most one department (&lt;=1), and a department can have several employees._

**4)Many To Many (default)**



<p id="gdcalert17" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image17.jpg). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert18">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image17.jpg "image_tooltip")


_An employee can work in many departments (>=0), and a department can have several employees_


## Relational Model in DBMS

Relational Model was proposed by E.F. Codd to model data in the form of relations or tables. After designing the conceptual model of the Database using ER diagram, we need to convert the conceptual model into the relational model which can be implemented using any RDBMS languages like Oracle SQL, MySQL etc. So we will see what the Relational Model is.

Relational Model represents how data is stored in Relational Databases.  A relational database stores data in the form of relations (tables).

**STUDENT TABEL**


<table>
  <tr>
   <td><strong>ROLL_NO</strong>
   </td>
   <td><strong>NAME</strong>
   </td>
   <td><strong>ADDRESS</strong>
   </td>
   <td><strong>PHONE</strong>
   </td>
   <td><strong>AGE</strong>
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>RAM
   </td>
   <td>DELHI
   </td>
   <td>9455123451
   </td>
   <td>18
   </td>
  </tr>
  <tr>
   <td>2
   </td>
   <td>RAMESH
   </td>
   <td>GURGAON
   </td>
   <td>9652431543
   </td>
   <td>18
   </td>
  </tr>
  <tr>
   <td>3
   </td>
   <td>SUJIT
   </td>
   <td>ROHTAK
   </td>
   <td>9156253131
   </td>
   <td>20
   </td>
  </tr>
  <tr>
   <td>4
   </td>
   <td>SURESH
   </td>
   <td>DELHI
   </td>
   <td> 
   </td>
   <td>18
   </td>
  </tr>
</table>




* **Attribute**: Attributes are the properties that define a relation. e.g.; ROLL_NO, NAME
* **Relation Schema**: A relation schema represents the name of the relation with its attributes. e.g.; _STUDENT _(_ROLL_NO, NAME, ADDRESS, PHONE and AGE)_ is relation schema for _STUDENT_. If a schema has more than 1 relation, it is called Relational Schema.
* **Tuple**: Each row in the relation is known as tuple. The above relation contains 4 tuples, one of which is shown as:

<table>
  <tr>
   <td>
1
   </td>
   <td>RAM
   </td>
   <td>DELHI
   </td>
   <td>9455123451
   </td>
   <td>18
   </td>
  </tr>
</table>




* **Relation Instance**: The set of tuples of a relation at a particular instance of time is called a relation instance. Table 1 shows the relation instance of STUDENT at a particular time. It can change whenever there is insertion, deletion or updation in the database.
* **Degree**: The number of attributes in the relation is known as degree of the relation. The STUDENT relation defined above has degree 5.
* **Cardinality**: The number of tuples in a relation is known as cardinality. _STUDENT _relation defined above has cardinality 4.
* **Column**: Column represents the set of values for a particular attribute. The column _ROLL_NO _is extracted from relation STUDENT.


## Mapping from ER Model to Relational Model

After designing the ER diagram of a system, we need to convert it to Relational models which can directly be implemented by any RDBMS like Oracle, MySQL etc. 

**Case 1:  Binary Relationship with 1:1 cardinality with the total participation of an entity**



<p id="gdcalert18" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image18.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert19">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image18.png "image_tooltip")


A person has 0 or 1 passport number and Passport is always owned by 1 person. So it is 1:1 cardinality with full participation constraint from Passport.


<table>
  <tr>
   <td colspan="2" ><strong>Person</strong>
   </td>
   <td rowspan="4" >
   </td>
   <td colspan="2" ><strong>Has</strong>
   </td>
   <td rowspan="4" >
   </td>
   <td colspan="2" ><strong>Passport</strong>
   </td>
  </tr>
  <tr>
   <td>Per-Id
   </td>
   <td>Other Person Attribute
   </td>
   <td>Per-Id
   </td>
   <td>Pass-No
   </td>
   <td>Pass-No
   </td>
   <td>Other PassportAttribute
   </td>
  </tr>
  <tr>
   <td>PR1
   </td>
   <td>–
   </td>
   <td>PR1
   </td>
   <td>PS1
   </td>
   <td>PS1
   </td>
   <td>–
   </td>
  </tr>
  <tr>
   <td>PR2
   </td>
   <td>–
   </td>
   <td>PR2
   </td>
   <td>PS2
   </td>
   <td>PS2
   </td>
   <td>–
   </td>
  </tr>
  <tr>
   <td>PR3
   </td>
   <td>–
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
</table>


As we can see from Table 1, each Per-Id and Pass-No has only one entry in Hash table. So we can merge all three tables into 1 with attributes shown in Table 2. Each Per-Id will be unique and not null. So it will be the key. Pass-No can’t be key because, for some person, it can be NULL.


<table>
  <tr>
   <td>Per-Id
   </td>
   <td>Other Person Attribute
   </td>
   <td>Pass-No
   </td>
   <td>Other PassportAttribute
   </td>
  </tr>
</table>


**Case 2: Binary Relationship with 1:1 cardinality and partial participation of both entities**



<p id="gdcalert19" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image19.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert20">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image19.png "image_tooltip")


A male marries 0 or 1 female and vice versa as well. So it is 1:1 cardinality with partial participation constraint from both. First Convert each entity and relationship to tables.  Male table corresponds to Male Entity with key as M-Id. Similarly, Female table corresponds to the Female Entity with key as F-Id. Marry Table represents the relationship between Male and Female (Which Male marries which female). So it will take attribute M-Id from Male and F-Id from Female.


<table>
  <tr>
   <td colspan="2" ><strong>Male</strong>
   </td>
   <td rowspan="4" >
   </td>
   <td colspan="2" ><strong>Marry</strong>
   </td>
   <td rowspan="4" >
   </td>
   <td colspan="2" ><strong>Female</strong>
   </td>
  </tr>
  <tr>
   <td>M-Id
   </td>
   <td>Other Male Attribute
   </td>
   <td>M-Id
   </td>
   <td>F-Id
   </td>
   <td>F-Id
   </td>
   <td>Other FemaleAttribute
   </td>
  </tr>
  <tr>
   <td>M1
   </td>
   <td>–
   </td>
   <td>M1
   </td>
   <td>F2
   </td>
   <td>F1
   </td>
   <td>–
   </td>
  </tr>
  <tr>
   <td>M2
   </td>
   <td>–
   </td>
   <td>M2
   </td>
   <td>F1
   </td>
   <td>F2
   </td>
   <td>–
   </td>
  </tr>
  <tr>
   <td>M3
   </td>
   <td>–
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>F3
   </td>
   <td>–
   </td>
  </tr>
</table>


**Note**: Binary relationship with 1:1 cardinality will have 2 tables if partial participation of both entities in the relationship. If at least 1 entity has total participation, number of tables required will be 1.

**Case 3: Binary Relationship with n: 1 cardinality**



<p id="gdcalert20" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image20.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert21">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image20.png "image_tooltip")




* **Primary is always on many sides**
* **We can only merge table on many sidesThe students**

In an elective course, there can be more than one student. First Convert each entity and relationship to tables.  Student table corresponds to the Student Entity with a key as _S-Id_. Similarly, _Elective_Course _table corresponds to _Elective_Course _Entity with key as _E-Id_. Enrolls Table represents the relationship between Student and _Elective_Course _(Which student enrols in which course). So it will take the attribute _S-Id _from and Student _E-Id _from _Elective_Course_.


<table>
  <tr>
   <td colspan="2" ><strong>Student</strong>
   </td>
   <td rowspan="4" >
   </td>
   <td colspan="2" ><strong>Enrolls</strong>
   </td>
   <td rowspan="4" >
   </td>
   <td colspan="2" ><strong>Elective_Course</strong>
   </td>
  </tr>
  <tr>
   <td>S-Id
   </td>
   <td>Other Student Attribute
   </td>
   <td>S-Id
   </td>
   <td>E-Id
   </td>
   <td>E-Id
   </td>
   <td>Other Elective CourseAttribute
   </td>
  </tr>
  <tr>
   <td>S1
   </td>
   <td>–
   </td>
   <td>S1
   </td>
   <td>E1
   </td>
   <td>E1
   </td>
   <td>–
   </td>
  </tr>
  <tr>
   <td>S2
   </td>
   <td>–
   </td>
   <td>S2
   </td>
   <td>E2
   </td>
   <td>E2
   </td>
   <td>–
   </td>
  </tr>
  <tr>
   <td>S3
   </td>
   <td>–
   </td>
   <td>
   </td>
   <td>S3
   </td>
   <td>E1
   </td>
   <td>
   </td>
   <td>E3
   </td>
   <td>–
   </td>
  </tr>
  <tr>
   <td>S4
   </td>
   <td>–
   </td>
   <td>
   </td>
   <td>S4
   </td>
   <td>E1
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
</table>


As we can see from Table 6, S-Id is not repeating in Enrolls Table. So it can be considered as a key to the Enrolls table. Both the Student and Enroll Table’s key is the same; we can merge it as a single table. The resultant tables are shown below. Primary Keys have been underlined.


<table>
  <tr>
   <td><span style="text-decoration:underline;">S-Id</span>
   </td>
   <td>Other Student Attribute
   </td>
   <td>E-Id
   </td>
  </tr>
</table>



<table>
  <tr>
   <td><span style="text-decoration:underline;">E-Id</span>
   </td>
   <td>Other Elective CourseAttribute
   </td>
  </tr>
</table>


**Case 4: Binary Relationship with m: n cardinality**



<p id="gdcalert21" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image21.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert22">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image21.png "image_tooltip")


In this scenario, every student can enrol in more than 1 compulsory course and for a compulsory course, there can be more than 1 student. First Convert each entity and relationship to tables.  Student table corresponds to the Student Entity with a key as S-Id. Similarly, _Compulsory_Courses _table corresponds to the Compulsory Courses Entity with key as C-Id. Enrolls Table represents the relationship between Student and _Compulsory_Courses _(Which student enrols in which course). So it will take the attributes S-Id from Person and C-Id from Compulsory_Courses.


<table>
  <tr>
   <td colspan="2" ><strong>Student</strong>
   </td>
   <td rowspan="4" >
   </td>
   <td colspan="2" ><strong>Enrolls</strong>
   </td>
   <td rowspan="4" >
   </td>
   <td colspan="2" ><strong>Compulsory_Courses</strong>
   </td>
  </tr>
  <tr>
   <td>S-Id
   </td>
   <td>Other Student Attribute
   </td>
   <td>S-Id
   </td>
   <td>C-Id
   </td>
   <td>C-Id
   </td>
   <td>Other Compulsory CourseAttribute
   </td>
  </tr>
  <tr>
   <td>S1
   </td>
   <td>–
   </td>
   <td>S1
   </td>
   <td>C1
   </td>
   <td>C1
   </td>
   <td>–
   </td>
  </tr>
  <tr>
   <td>S2
   </td>
   <td>–
   </td>
   <td>S1
   </td>
   <td>C2
   </td>
   <td>C2
   </td>
   <td>–
   </td>
  </tr>
  <tr>
   <td>S3
   </td>
   <td>–
   </td>
   <td>
   </td>
   <td>S3
   </td>
   <td>C1
   </td>
   <td>
   </td>
   <td>C3
   </td>
   <td>–
   </td>
  </tr>
  <tr>
   <td>S4
   </td>
   <td>–
   </td>
   <td>
   </td>
   <td>S4
   </td>
   <td>C3
   </td>
   <td>
   </td>
   <td>C4
   </td>
   <td>–
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>S4
   </td>
   <td>C2
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>S3
   </td>
   <td>C3
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
</table>


As we can see from Table 9, S-Id and C-Id both are repeating in Enrolls Table. But its combination is unique; so it can be considered as a key of Enrolls table. All tables’ keys are different, these can’t be merged.  Primary Keys of all tables have been underlined.


# Relational Database Design

**Characteristics**



* All data are represented as tables (relations)
* Tables are comprised of rows and columns (tuples)
* Rows are (officially) unordered (i.e., the order in which rows are referenced does not matter)
* A proper relational table contains **no duplicate rows**.
* Each table has a **primary key**, a unique identifier constructed from one or more columns
* Most primary keys are a single column (e.g., OWNERNUM for OWNERS)
* A table is linked to another by including the other table's primary key. Such an included column is called a **foreign key**

**Qualities of a Good Database Design**



* Reflects real-world structure of the problem
* Can represent all expected data over time
* Avoids redundant storage of data items
* Provides efficient access to data
* Supports the maintenance of data integrity over time
* Clean, consistent, and easy to understand
* Note: These objectives are sometimes contradictory!


## Functional Dependency in DBMS?

Functional Dependency (FD) is a constraint that determines the relation of one attribute to another attribute in a Database Management System (DBMS). Functional Dependency helps to maintain the quality of data in the database. It plays a vital role to find the difference between good and bad database design.

A functional dependency is denoted by an arrow_ "→"_. The functional dependency of _X _on _Y _is represented by _X → Y_. Let's understand Functional Dependency in DBMS with an example.

**Example**


<table>
  <tr>
   <td>Employee number
   </td>
   <td>Employee Name
   </td>
   <td>Salary
   </td>
   <td>City
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>Dana
   </td>
   <td>50000
   </td>
   <td>San Francisco
   </td>
  </tr>
  <tr>
   <td>2
   </td>
   <td>Francis
   </td>
   <td>38000
   </td>
   <td>London
   </td>
  </tr>
  <tr>
   <td>3
   </td>
   <td>Andrew
   </td>
   <td>25000
   </td>
   <td>Tokyo
   </td>
  </tr>
</table>


In this example, if we know the value of Employee number, we can obtain Employee Name, city, salary, etc. By this, we can say that the city, Employee Name, and salary are functionally dependent on Employee number.

**Key Terms**


<table>
  <tr>
   <td><strong>Key Terms</strong>
   </td>
   <td><strong>Description</strong>
   </td>
  </tr>
  <tr>
   <td><strong>Axiom</strong>
   </td>
   <td>Axioms is a set of inference rules used to infer all the functional dependencies on a relational database.
   </td>
  </tr>
  <tr>
   <td><strong>Decomposition</strong>
   </td>
   <td>It is a rule that suggests if you have a table that appears to contain two entities that are determined by the same primary key then you should consider breaking them up into two different tables.
   </td>
  </tr>
  <tr>
   <td><strong>Dependent</strong>
   </td>
   <td>It is displayed on the right side of the functional dependency diagram.
   </td>
  </tr>
  <tr>
   <td><strong>Determinant</strong>
   </td>
   <td>It is displayed on the left side of the functional dependency Diagram.
   </td>
  </tr>
  <tr>
   <td><strong>Union</strong>
   </td>
   <td>It suggests that if two tables are separate, and the PK is the same, you should consider putting them. together
   </td>
  </tr>
</table>


**Rules of Functional Dependencies**



* **Reflexive rule **– If X is a set of attributes and Y is_subset_of X, then X holds a value of Y.
* **Augmentation rule** − If a → b holds and y is attribute set, then ay → by also holds. That is adding attributes in dependencies, does not change the basic dependencies.
* **Transitivity rule**- This rule is very much similar to the transitive rule in algebra if x -> y holds and y -> z holds, then x -> z also holds. X -> y is called functionally that determines y.

**Types of Functional Dependencies in DBMS**



1. **Multivalued Dependency in DBMS**

    Multivalued dependency occurs in a situation where there are multiple independent multivalued attributes in a single table. A multivalued dependency is a complete constraint between two sets of attributes in a relation. It requires that certain tuples be present in a relation. Consider the following Multivalued Dependency Example to understand.


Example:


<table>
  <tr>
   <td>Car_model
   </td>
   <td>Maf_year
   </td>
   <td>Colour
   </td>
  </tr>
  <tr>
   <td>H001
   </td>
   <td>2017
   </td>
   <td>Metallic
   </td>
  </tr>
  <tr>
   <td>H001
   </td>
   <td>2017
   </td>
   <td>Green
   </td>
  </tr>
  <tr>
   <td>H005
   </td>
   <td>2018
   </td>
   <td>Metallic
   </td>
  </tr>
  <tr>
   <td>H005
   </td>
   <td>2018
   </td>
   <td>Blue
   </td>
  </tr>
  <tr>
   <td>H010
   </td>
   <td>2015
   </td>
   <td>Metallic
   </td>
  </tr>
  <tr>
   <td>H033
   </td>
   <td>2012
   </td>
   <td>Gray
   </td>
  </tr>
</table>


In this example, _maf_year _and colour are independent of each other but dependent on _car_model_. In this example, these two columns are said to be multi-value dependent on _car_model_.

This dependence can be represented like this:

_car_model -> maf_year_

_car_model-> colour_



1. **Trivial Functional Dependency in DBMS**

The Trivial dependency is a set of attributes that are called trivial if the set of attributes are included in that attribute.

So, X -> Y is a trivial functional dependency if Y is a subset of X. Let's understand with a Trivial Functional Dependency Example.

For example:


<table>
  <tr>
   <td><strong>Emp_id</strong>
   </td>
   <td><strong>Emp_name</strong>
   </td>
  </tr>
  <tr>
   <td>AS555
   </td>
   <td>Harry
   </td>
  </tr>
  <tr>
   <td>AS811
   </td>
   <td>George
   </td>
  </tr>
  <tr>
   <td>AS999
   </td>
   <td>Kevin
   </td>
  </tr>
</table>


Consider this table with two columns _Emp_id _and _Emp_name_.

{_Emp_id_, _Emp_name_} -> _Emp_id _is a trivial functional dependency as _Emp_id _is a subset of {_Emp_id_,_Emp_name_}.

**Non-Trivial Functional Dependency in DBMS**

Functional dependency which is also known as a nontrivial dependency occurs when A->B holds where B is not a subset of A. In a relationship, if attribute B is not a subset of attribute A, then it is considered as a non-trivial dependency.


<table>
  <tr>
   <td>Company
   </td>
   <td>CEO
   </td>
   <td>Age
   </td>
  </tr>
  <tr>
   <td>Microsoft
   </td>
   <td>Satya Nadella
   </td>
   <td>51
   </td>
  </tr>
  <tr>
   <td>Google
   </td>
   <td>Sundar Pichai
   </td>
   <td>46
   </td>
  </tr>
  <tr>
   <td>Apple
   </td>
   <td>Tim Cook
   </td>
   <td>57
   </td>
  </tr>
</table>


Example:

(Company} -> {CEO} (if we know the Company, we knows the CEO name)

But CEO is not a subset of Company, and hence it's a non-trivial functional dependency.

**Transitive Dependency in DBMS**

A Transitive Dependency is a type of functional dependency which happens when it is indirectly formed by two functional dependencies. Let's understand with the following Transitive Dependency Example.

Example:


<table>
  <tr>
   <td>Company
   </td>
   <td>CEO
   </td>
   <td>Age
   </td>
  </tr>
  <tr>
   <td>Microsoft
   </td>
   <td>Satya Nadella
   </td>
   <td>51
   </td>
  </tr>
  <tr>
   <td>Google
   </td>
   <td>Sundar Pichai
   </td>
   <td>46
   </td>
  </tr>
  <tr>
   <td>Alibaba
   </td>
   <td>Jack Ma
   </td>
   <td>54
   </td>
  </tr>
</table>


{Company} -> {CEO} (if we know the company, we know its CEO's name)

{CEO } -> {Age} If we know the CEO, we know the Age

Therefore according to the rule of transitive dependency:

{ Company} -> {Age} should hold, that makes sense because if we know the company name, we can know his age.

Note: You need to remember that transitive dependency can only occur in a relation of three or more attributes.


## What is Normalization?

Normalization is a database design technique that reduces data redundancy and eliminates undesirable characteristics like Insertion, Update and Deletion Anomalies. Normalization rules divide larger tables into smaller tables and link them using relationships. The purpose of Normalization in SQL is to eliminate redundant (repetitive) data and ensure data is stored logically.

**Database Normal Forms**

Here is a list of Normal Forms:



* 1NF (First Normal Form)
* 2NF (Second Normal Form)
* 3NF (Third Normal Form)
* BCNF (Boyce-Codd Normal Form)
* 4NF (Fourth Normal Form)
* 5NF (Fifth Normal Form)
* 6NF (Sixth Normal Form)

However, in most practical applications, normalization achieves its best in 3<sup>rd</sup> Normal Form.



<p id="gdcalert22" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image22.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert23">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image22.png "image_tooltip")


**First Normal Form (1NF):**

If a relation contains a composite or multi-valued attribute, it violates the first normal form, or relation is in first normal form if it does not contain any composite or multi-valued attribute. A relation is in first normal form if every attribute in that relation is a single-valued attribute.

A table is in 1 NF iff:



1. There are only Single Valued Attributes.
2. Attribute Domain does not change.
3. There is a unique name for every Attribute/Column.
4. The order in which data is stored does not matter.

Consider the examples given below.


```
ID   Name   Courses
------------------
1    A      c1, c2
2    E      c3
3    M      C2, c3
```


In the above table, Course is a multi-valued attribute so it is not in 1NF.

Below Table is in 1NF as there is no multi-valued attribute:


```
ID   Name   Course
------------------
1    A       c1
1    A       c2
2    E       c3
3    M       c1
3    M       c2
```


Second Normal Form (2NF) is based on the concept of fully functional dependency. Second Normal Form applies to relations with composite keys, that is, relations with a primary key composed of two or more attributes. A relation with a single-attribute primary key is automatically in at least 2NF. A relation that is not in 2NF may suffer from the update anomalies.

To be in second normal form, a relation must be in first normal form and relation must not contain any partial dependency. A relation is in 2NF if it has No Partial Dependency, i.e., no non-prime attribute (attributes which are not part of any candidate key) is dependent on any proper subset of any candidate key of the table.


## Second Normal Form (2NF)

Second Normal Form (2NF) is based on the concept of fully functional dependency. Second Normal Form applies to relations with composite keys, that is, relations with a primary key composed of two or more attributes. A relation with a single-attribute primary key is automatically in at least 2NF. A relation that is not in 2NF may suffer from the update anomalies.

To be in second normal form, a relation must be in first normal form and relation must not contain any partial dependency. A relation is in 2NF if it has No Partial Dependency, i.e., no non-prime attribute (attributes which are not part of any candidate key) is dependent on any proper subset of any candidate key of the table.

**_A relation that is in First Normal Form and every non-primary-key attribute is fully functionally dependent on the primary key, then the relation is in Second Normal Form (2NF)._**

** An attribute is used to form a candidate key is known as a prime attribute.

** An attribute not participating in the information of candidate key is known as a non-prime attribute.

Consider the table as follows below:


```
STUD_NO            COURSE_NO        COURSE_FEE
1                     C1                  1000
2                     C2                  1500
1                     C4                  2000
4                     C3                  1000
4                     C1                  1000
2                     C5                  2000
```


Here,

_COURSE_FEE _cannot alone decide the value of _COURSE_NO _or _STUD_NO_;

_COURSE_FEE _together with _STUD_NO _cannot decide the value of _COURSE_NO_;

_COURSE_FEE _together with _COURSE_NO _cannot decide the value of _STUD_NO_;

Hence,

_COURSE_FEE _would be a non-prime attribute, as it does not belong to the one only candidate key {_STUD_NO_, _COURSE_NO_} ;

But, COURSE_NO -> COURSE_FEE, i.e., COURSE_FEE is dependent on COURSE_NO, which is a proper subset of the candidate key. Non-prime attribute COURSE_FEE is dependent on a proper subset of the candidate key, which is a partial dependency and so this relation is not in 2NF.

To convert the above relation to 2NF,

we need to split the table into two tables such as :

Table 1: STUD_NO, COURSE_NO

Table 2: COURSE_NO, COURSE_FEE


```
      Table 1                        Table 2
STUD_NO    COURSE_NO       COURSE_NO          COURSE_FEE     
1            C1               C1               1000
2            C2               C2       	      1500
1            C4               C3               1000
4            C3               C4               2000
4            C1               C5               2000        
2            C5                
```


**Note **– 2NF tries to reduce the redundant data getting stored in memory. For instance, if there are 100 students taking a C1 course, we don't need to store its Fee as 1000 for all the 100 records, instead, once we can store it in the second table as the course fee for C1 is 1000.        



<p id="gdcalert23" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image23.jpg). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert24">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image23.jpg "image_tooltip")



## Third Normal Form (3NF)

Although Second Normal Form (2NF[)](https://www.geeksforgeeks.org/second-normal-form-2nf/) relations have less redundancy than those in 1NF, they may still suffer from update anomalies. If we update only one tuple and not the other, the database would be in an inconsistent state. This update anomaly is caused by a transitive dependency. We need to remove such dependencies by progressing to the Third Normal Form (3NF).

**Third Normal Form (3NF):**

A relation is in third normal form if there is no transitive dependency for non-prime attributes as well as it is in second normal form.

A relation is in 3NF if at least one of the following condition holds in every non-trivial functional dependency X –> Y:



1. X is a super key.
2. Y is a prime attribute (each element of Y is part of some candidate key).

In other words,

**_A relation that is in First and Second Normal Form and in which no non-primary-key attribute is transitively dependent on the primary key, then it is in Third Normal Form (3NF)._**

**Example :**

In relation STUDENT given in Table,



<p id="gdcalert24" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image24.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert25">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image24.png "image_tooltip")


FD set:

{STUD_NO -> STUD_NAME, STUD_NO -> STUD_STATE, STUD_STATE -> STUD_COUNTRY, STUD_NO -> STUD_AGE}

Candidate Key:

{STUD_NO}

For this relation in the table, STUD_NO -> STUD_STATE and STUD_STATE -> STUD_COUNTRY are true. So STUD_COUNTRY is transitively dependent on STUD_NO. It violates the third normal form. To convert it in third normal form, we will decompose the relation STUDENT (STUD_NO, STUD_NAME, STUD_PHONE, STUD_STATE, STUD_COUNTRY_STUD_AGE) as:


```
STUDENT (STUD_NO, STUD_NAME, STUD_PHONE, STUD_STATE, STUD_AGE) 
STATE_COUNTRY (STATE, COUNTRY)
```



## Boyce-Codd Normal Form(BCNF):

Boyce–Codd Normal Form (BCNF) is based on functional dependencies that take into account all candidate keys in a relation; however, BCNF also has additional constraints compared with the general definition of 3NF. 

A relation is in BCNF iff, X is superkey for every functional dependency (FD) X?Y in the given relation.

In other word,

**_A relation is in BCNF, if and only if, every determinant is a Form (BCNF) candidate key._**



<p id="gdcalert25" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image25.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert26">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image25.png "image_tooltip")



## Lossy Vs Lossless Decomposition


<table>
  <tr>
   <td><strong>Lossless</strong>
   </td>
   <td><strong>Lossy</strong>
   </td>
  </tr>
  <tr>
   <td>The decompositions R1, R2, R2…Rn for a relation schema R are said to be Lossless if their natural join results in the original relation R.
   </td>
   <td>The decompositions R1, R2, R2…Rn for a relation schema R are said to be Lossy if their natural join results into addition of extraneous tuples with the original relation R.
   </td>
  </tr>
  <tr>
   <td>Formally, Let R be a relation and R1, R2, R3 … Rn be it’s decomposition, the decomposition is lossless if –
<p>
R1 ⨝ R2 ⨝ R3 .... ⨝ Rn = R
   </td>
   <td>Formally, Let R be a relation and R1, R2, R3 … Rn be it’s decomposition, the decomposition is lossy if –
<p>
R ⊂ R1 ⨝ R2 ⨝ R3 .... ⨝ Rn
   </td>
  </tr>
  <tr>
   <td>There is no loss of information as the relation obtained after natural join of decompositions is equivalent to original relation.Thus, it is also referred to as non-additive join decomposition
   </td>
   <td>There is loss of information as extraneous tuples are added into the relation after natural join of decompositions. Thus, it is also referred to as careless decomposition.
   </td>
  </tr>
  <tr>
   <td>The common attribute of the sub relations is a superkey of any one of the relations.
   </td>
   <td>The common attribute of the sub relation is not a superkey of any of the sub relation.
   </td>
  </tr>
</table>



## Summery



<p id="gdcalert26" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image26.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert27">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image26.png "image_tooltip")


 Condition for : 



* 1 NF : In single sell no multi attribute present.
* 2NF : !( (LHS is proper subset of any candidate key) && (RHS should be non prime attribute))
* 3NF : (LHS must be candidate key or Super key) || (RHS is a prime attribute)
* BCNF : LHS must be candidate key or Super key


## What is the Purpose of Database Normalisation?



1. **Prevent the Same Data from Being Stored in Many Places**

One of the advantages of normalisation is to prevent the same data from being stored in many places.

Let’s take this table as an example:



<p id="gdcalert27" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image27.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert28">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image27.png "image_tooltip")


We have 5 employees shown here in this “employee” table. Each employee can be in a department, such as Finance, Sales, or Customer Support. Each employee is in a location as well.

We can see that the name of the department is stored in a few rows. The department name is something stored for each customer. But what if we insert a new row? We would need to make sure that the value matches one of the existing values if we want to keep our data consistent. This could be done with application code, but it would not be very simple.

The same issue occurs for Location. If we want to find out all of the locations, we need to look up all the unique values in this column.

This data looks OK, but the values are determined by what was entered. Is Chicago the same as North Chicago or are they different? Are both Chicago locations the same, or are they different offices in the same city?

In a normalised table, the Departments would be stored in their own table:



<p id="gdcalert28" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image28.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert29">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image28.png "image_tooltip")
         

<p id="gdcalert29" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image29.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert30">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image29.png "image_tooltip")


This also means the Employee table would just store references to this data:



<p id="gdcalert30" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image30.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert31">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image30.png "image_tooltip")




2. **Prevent Updates made to Some Data and Not Others**

Another reason we should normalise our database is to avoid something called an “update anomaly”, or an issue with updating data.

Let’s say we had our sample data again:



<p id="gdcalert31" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image31.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert32">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image31.png "image_tooltip")


Let’s then say that we want to update the name of one of the departments. We want to update “Finance” to say “Accounting”.

We would update the data so it looks like this:

<p id="gdcalert32" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image32.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert33">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image32.png "image_tooltip")


This means we need to update every value in the table.

What if we miss one? What if someone adds a new value while we are performing this update? What if someone overwrites the value, or does something else to one of the rows, which means our update didn’t work?

**Solution:**

If the data is normalised, like our earlier example, there would be one record in a “department” table that contains the value of “Finance”. We would change this single value to say “Accounting”. All employees that related to the department ID would then show the updated name in the systems that used this.



<p id="gdcalert33" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image33.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert34">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image33.png "image_tooltip")


The employee table is unaffected.



<p id="gdcalert34" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image34.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert35">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image34.png "image_tooltip")




3. **Prevent Deleting Unrelated Data**

Another reason for normalising our database is to prevent “delete anomalies”. This is where we delete a record and other information is also deleted — a kind of unintended side effect of what we did.

Let’s return to our original example:



<p id="gdcalert35" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image35.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert36">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image35.png "image_tooltip")


Let’s say we delete Mary Taylor from the system, who has an employee 

Id of 2.



<p id="gdcalert36" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image36.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert37">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image36.png "image_tooltip")


Now, assuming this is all of the data in the table, we now have no information about Mary. This may be OK.

But, we also lost any record of a Customer Support department.



4. **Ensure Queries are More Efficient**

The final reason I’d like to mention that normalisation is useful is that it ensures your queries are more efficient.

Before your data is normalised, it’s all in one table or a small number of tables. To find the data you need, you’ll have to:



* Select the columns you want from this table
* Use quite a few WHERE clauses
* Probably perform some string manipulation
* Perhaps use a subquery or two to get what you want.

This is because you can’t see how records are related to each other.

However, with your normalised database, you can:



* Select only the columns you need
* Use joins to relate data in several tables, only getting the data you need
* Easily use WHERE clauses to filter data to what you need, likely avoiding subqueries and string manipulation

It’s much easier to query a normalised database than one that is not normalised.

It’s also easier to insert or update data because we only need to insert or update one set of related data in one table, and not have to specify data for all other related columns.

The only exception would be data warehouses, which use a “de-normalised” design. This design follows another set of design practices and is optimised for querying and not updating. However, that design method is still better than not normalising at all.


## Three Anomalies resolved by normalisation



1. **Insertion anomaly**: If you have one big _enrollment _table that includes both "class" and "student" data (neither of which exists elsewhere), then you can't enter a new (empty) course without at least one corresponding student (because the table is a record of your enrollments). So, apply 2NF and create separate tables for _classes_, _students_, and make your original _enrollment _table link to both by ClassID and StudentID. Now you can enter new classes with no students, and new students with no classes.

    2.** Deletion anomaly:** Same as above, if each row of your original _enrollment _table contains the full details of the student and the full details of the class they are enrolled in, then removing the last enrolled student for a class_ removes the last bit of information about that class_. The solution is the same, apply 2NF to make separate tables, so that students can be enrolled or unenrolled without losing class information.


    3. **Update anomaly**: Same as above, using the single-table method, updating information (say, the room number) for a class with multiple students enrolled might lead to a situation where some rows have been new information and other rows have the old. Applying 2NF as above is again the solution three types of relationships can so that class data is changed in only one place (the classes table).



# SQL

([cheatsheet](https://www.educba.com/cheat-sheet-sql/?source=leftnav))

**What is SQL?**



* SQL stands for Structured Query Language
* SQL lets you access and manipulate databases
* Support at least major commands(such as SELECT, UPDATE, DELETE, INSERT, WHERE)
* DDL, DML, DCL, TCL

**Difference between SQL and MySQL:**



* SQL is a query language, whereas MySQL is a relational database that uses SQL to query a database.
* You can use SQL to access, update, and manipulate the data stored in a database. However, MySQL is a database that stores the existing data in a database in an organized manner. 
* SQL is used for writing queries for databases, MySQL facilitates data storing, modifying, and management in a tabular format. 
* SQL does not have support for any connectors. However, MySQL comes with an integrated tool – MySQL workbench – for designing and building databases. 
* SQL is not an open-source language. Naturally, if you experience any issue, you cannot expect community support. Instead, you’ll have to rely on Microsoft SQL Server support. Contrary to this, MySQL being an open-source platform, offers rich and robust community support. 


## Important Keywords:

([Important Keywords)](https://www.educba.com/sql-keywords/)

[(Joins vs nested subquery vs correlated subquery)](https://www.youtube.com/watch?v=bonJEipf3VU&list=PLxCzCOWd7aiFAN6I8CuViBuCdJgiOkT2Y&index=68)

The various keywords in SQL provide flexibility in designing a database, tables, etc. They provide the designer with many features which become very useful while making any changes after the design is completed.

**The following constraints are commonly used in SQL:**



* [NOT NULL](https://www.w3schools.com/sql/sql_notnull.asp) - Ensures that a column cannot have a NULL value
* [UNIQUE](https://www.w3schools.com/sql/sql_unique.asp) - Ensures that all values in a column are different
* [PRIMARY KEY](https://www.w3schools.com/sql/sql_primarykey.asp) - A combination of a NOT NULL and UNIQUE. Uniquely identifies each row in a table
* [FOREIGN KEY](https://www.w3schools.com/sql/sql_foreignkey.asp) - Prevents actions that would destroy links between tables
* [CHECK](https://www.w3schools.com/sql/sql_check.asp) - Ensures that the values in a column satisfies a specific condition
* [DEFAULT](https://www.w3schools.com/sql/sql_default.asp) - Sets a default value for a column if no value is specified
* [CREATE INDEX](https://www.w3schools.com/sql/sql_create_index.asp) - Used to create and retrieve data from the database very quickly


## Primary key vs Unique key



<p id="gdcalert37" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image37.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert38">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image37.png "image_tooltip")



## Alter Vs Update



<p id="gdcalert38" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image38.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert39">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image38.png "image_tooltip")



## Delete vs Truncate vs Drop



<p id="gdcalert39" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image39.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert40">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image39.png "image_tooltip")



## IN and NOT IN



<p id="gdcalert40" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image40.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert41">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image40.png "image_tooltip")


**IN**

_SELECT Column(s) FROM table_name WHERE column IN (value1, value2, ... valueN);_

_SELECT StudentPercent FROM Student WHERE StudentAge IN ('12', '13');_

**NOT IN**

SELECT Column(s) FROM table_name WHERE Column NOT IN (value1, value2... valueN);

SELECT StudentPercent FROM Student WHERE StudentAge NOT IN ('12', '13');


## Exist and Not Exist

**Exist**



* The EXISTS operator is used to test for the existence of any record in a subquery.
* The EXISTS operator returns TRUE if the subquery returns one or more records.

_SELECT column_name(s)	_

_FROM table_name_

_WHERE EXISTS_

_(SELECT column_name FROM table_name WHERE condition);_


## Aggregate Function

In database management an aggregate function is a function where the values of multiple rows are grouped together as input on certain criteria to form a single value of more significant meaning.

_ _

**Various Aggregate Functions**



1. <code><em> Count()</em></code>
2. <code><em> Sum()</em></code>
3. <code><em> Avg()</em></code>
4. <code><em> Min()</em></code>
5. <code><em> Max()</em></code>


## Like Operator

The _LIKE _operator is used in a _WHERE _clause to search for a specified pattern in a column.

There are two wildcards often used in conjunction with the _LIKE _operator:



*  The percent sign (%) represents zero, one, or multiple characters
*  The underscore sign (_) represents one, single character

**Note**: MS Access uses an asterisk (*) instead of the percent sign (%), and a question mark (?) instead of the underscore (_).


## Important Question

**Find nth highest salary**


```
SELECT name, salary FROM #Employee e1 WHERE N-1 = (SELECT COUNT(DISTINCT salary) FROM #Employee e2 WHERE e2.salary > e1.salary)
```



## Joins in DBMS



1. **Natural Join(⋈)**

A natural join is just like an INNER JOIN in functionality with only difference that the JOIN is created “naturally”. It is automatically done by using the likeliness of columns’ names and data type in the tables to be joined.

Syntax


```
SELECT column-name1, column-name2….
FROM table1 NATURAL JOIN table2
```




2. **Self Join**

A Self Join is a special join in which a table joins itself on two columns of table with different names but storing data from the same domain.  The table is defined with two aliases to differentiate as left and right table in the Self Join Query

Syntax


```
SELECT column-name1, column-name2….
FROM table1 T1, table2 T2
WHERE T1.Col-Name1=T2=Col-Name2

```



## SQL | Join (Inner, Left, Right and Full Joins)

A SQL Join statement is used to combine data or rows from two or more tables based on a common field between them. Different types of Joins are:



* INNER JOIN
* LEFT JOIN(

<p id="gdcalert41" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image41.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert42">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image41.png "image_tooltip")
)
* RIGHT JOIN(

<p id="gdcalert42" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image42.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert43">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image42.png "image_tooltip")
)
* FULL JOIN(

<p id="gdcalert43" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image43.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert44">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image43.png "image_tooltip")
)

Consider the two tables below:

					**Student**



<p id="gdcalert44" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image44.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert45">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image44.png "image_tooltip")


				**StudentCourse**


    

<p id="gdcalert45" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image45.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert46">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image45.png "image_tooltip")




1. **INNER JOIN**: The INNER JOIN keyword selects all rows from both the tables as long as the condition satisfies. This keyword will create the result-set by combining all rows from both the tables where the condition satisfies i.e value of the common field will be the same.

    **Syntax**:


    ```
SELECT table1.column1,table1.column2,table2.column1,....
FROM table1 
INNER JOIN table2
ON table1.matching_column = table2.matching_column;
```



	**Example**:


    _SELECT StudentCourse.COURSE_ID, Student.NAME, Student.AGE FROM Student_

_INNER JOIN StudentCourse_

_ON Student.ROLL_NO = StudentCourse.ROLL_NO;_

	**Output**:


    

<p id="gdcalert46" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image46.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert47">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image46.png "image_tooltip")



        

<p id="gdcalert47" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image47.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert48">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image47.png "image_tooltip")



                **Inner Join**



2. **LEFT JOIN**: This join returns all the rows of the table on the left side of the join and matching rows for the table on the right side of the join. The rows for which there is no matching row on the right side, the result-set will contain null. LEFT JOIN is also known as LEFT OUTER JOIN.Syntax:

    ```
SELECT table1.column1,table1.column2,table2.column1,....
FROM table1 
LEFT JOIN table2
ON table1.matching_column = table2.matching_column;
```



        

<p id="gdcalert48" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image48.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert49">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image48.png "image_tooltip")



    **	**


    **Example :**


    ```
SELECT Student.NAME,StudentCourse.COURSE_ID 
FROM Student
LEFT JOIN StudentCourse 
ON StudentCourse.ROLL_NO = Student.ROLL_NO;
```



**Output:**


    

<p id="gdcalert49" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image49.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert50">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image49.png "image_tooltip")




3. **Right Join:** RIGHT JOIN is similar to LEFT JOIN. This join returns all the rows of the table on the right side of the join and matching rows for the table on the left side of the join. The rows for which there is no matching row on the left side, the result-set will contain null. RIGHT JOIN is also known as RIGHT OUTER JOIN.

	

	**Syntex:**


```
SELECT table1.column1,table1.column2,table2.column1,....
FROM table1 
RIGHT JOIN table2
ON table1.matching_column = table2.matching_column;
```



```


```



            

<p id="gdcalert50" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image50.jpg). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert51">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image50.jpg "image_tooltip")


**Example:**


```
SELECT Student.NAME,StudentCourse.COURSE_ID 
FROM Student
RIGHT JOIN StudentCourse 
ON StudentCourse.ROLL_NO = Student.ROLL_NO;
```


**Output:**


    

<p id="gdcalert51" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image51.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert52">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image51.png "image_tooltip")




4. **FULL JOIN:**

    FULL JOIN creates the result-set by combining the result of both LEFT JOIN and RIGHT JOIN. The result-set will contain all the rows from both the tables. The rows for which there is no matching, the result-set will contain NULL values


    **Syntax:**


    ```
SELECT table1.column1,table1.column2,table2.column1,....
FROM table1 
FULL JOIN table2
ON table1.matching_column = table2.matching_column;
```



**	**

**				**

<p id="gdcalert52" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image52.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert53">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image52.png "image_tooltip")


**Example:**


```
SELECT Student.NAME,StudentCourse.COURSE_ID 
FROM Student
FULL JOIN StudentCourse 
ON StudentCourse.ROLL_NO = Student.ROLL_NO;
```


**Output:**

**		**

<p id="gdcalert53" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image53.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert54">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image53.png "image_tooltip")



## Relational Algebra in DBMS:



1. 
Projection:

    The projection eliminates all attributes of the input relation but those mentioned in the projection list. The projection method defines a relation that contains a vertical subset of Relation.


    This helps to extract the values of specified attributes to eliminate duplicate values. (pi) symbol is used to choose attributes from a relation. This operator helps you to keep specific columns from a relation and discards the other columns.


    **Example:**


        

<p id="gdcalert54" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image54.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert55">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image54.png "image_tooltip")


Here, the projection of CustomerName and status will give 


```
        Π CustomerName, Status (Customers)




<p id="gdcalert55" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image55.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert56">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image55.png "image_tooltip")

```



2. SELECT (σ):

    The SELECT operation is used for selecting a subset of the tuples according to a given selection condition. Sigma(σ)Symbol denotes it. It is used as an expression to choose tuples which meet the selection condition. Select operator selects tuples that satisfy a given predicate.


**Example 1**


```
σ topic = "Database" (Tutorials)
```


Output - Selects tuples from Tutorials where topic = 'Database'.

**Example 2**


```
σ topic = "Database" and author = "guru99"( Tutorials)
```



    Output - Selects tuples from Tutorials where the topic is 'Database' and 'author' is guru99.



3. 
Rename (ρ)

    Rename is a unary operation used for renaming attributes of a relation.

_ρ (a/b)R will rename the attribute 'b' of relation by 'a'._



4. 
Union operation (υ)

    UNION is symbolized by ∪ symbol. It includes all tuples that are in tables A or in B. It also eliminates duplicate tuples. So, set A UNION set B would be expressed as:

The result &lt;- A ∪ B


    For a union operation to be valid, the following conditions must hold -



* R and S must be the same number of attributes.
* Attribute domains need to be compatible.
* Duplicate tuples should be automatically removed.

Example

Consider the following tables:


    

<p id="gdcalert56" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image56.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert57">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image56.png "image_tooltip")


A ∪ B gives:



<p id="gdcalert57" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image57.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert58">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image57.png "image_tooltip")



### Set Difference (-)


    - Symbol denotes it. The result of A - B, is a relation which includes all tuples that are in A but not in B.



* The attribute name of A has to match with the attribute name in B.
* The two-operand relations A and B should be either compatible or Union compatible.
* It should be a defined relation consisting of the tuples that are in relation A, but not in B.

**Example**

A-B



<p id="gdcalert58" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image58.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert59">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image58.png "image_tooltip")



## Intersection

An intersection is defined by the symbol ∩

A ∩ B

Defines a relation consisting of a set of all tuples that are in both A and B. However, A and B must be union-compatible.



<p id="gdcalert59" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image59.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert60">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image59.png "image_tooltip")


**Example:**

A ∩ B


<table>
  <tr>
   <td colspan="2" >     Table A ∩ B
   </td>
  </tr>
  <tr>
   <td>column 1
   </td>
   <td>column 2
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>1
   </td>
  </tr>
</table>



## Division Method



<p id="gdcalert60" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image60.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert61">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image60.png "image_tooltip")



# Transaction Management:


## What is a transaction?

A transaction can be defined as a group of tasks. A single task is the minimum processing unit which cannot be divided further.


### Important keyword

**COMMIT command -**

COMMIT command is used to permanently save any transaction into the database.

When we use any DML command like INSERT, UPDATE or DELETE, the changes made by these commands are not permanent, until the current session is closed, the changes made by these commands can be rolled back.

To avoid that, we use the COMMIT command to mark the changes as permanent.

**ROLLBACK command -**

This command restores the database to the last committed state. It is also used with the SAVEPOINT command to jump to a savepoint in an ongoing transaction.

If we have used the UPDATE command to make some changes into the database, and realise that those changes were not required, then we can use the ROLLBACK command to rollback those changes, if they were not committed using the COMMIT command.

**SAVEPOINT command -**

SAVEPOINT command is used to temporarily save a transaction so that you can rollback to that point whenever required.


## ACID property:



<p id="gdcalert61" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image61.jpg). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert62">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image61.jpg "image_tooltip")




* **Atomicity **− This property states that a transaction must be treated as an atomic unit, that is, either all of its operations are executed or none. There must be no state in a database where a transaction is left partially completed. States should be defined either before the execution of the transaction or after the execution/abortion/failure of the transaction.
* **Consistency **− The database must remain in a consistent state after any transaction. No transaction should have any adverse effect on the data residing in the database. If the database was in a consistent state before the execution of a transaction, it must remain consistent after the execution of the transaction as well.
* **Durability **− The database should be durable enough to hold all its latest updates even if the system fails or restarts. If a transaction updates a chunk of data in a database and commits, then the database will hold the modified data. If a transaction commits but the system fails before the data could be written on to the disk, then that data will be updated once the system springs back into action.
* **Isolation **− In a database system where more than one transaction is being executed simultaneously and in parallel, the property of isolation states that all the transactions will be carried out and executed as if it is the only transaction in the system. No transaction will affect the existence of any other transaction.


## States of Transactions


## 

<p id="gdcalert62" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image62.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert63">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image62.png "image_tooltip")




* **Active **− In this state, the transaction is being executed. This is the initial state of every transaction.
* **Partially Committed** − When a transaction executes its final operation, it is said to be in a partially committed state.
* **Failed **− A transaction is said to be in a failed state if any of the checks made by the database recovery system fails. A failed transaction can no longer proceed further.
* **Aborted **− If any of the checks fails and the transaction has reached a failed state, then the recovery manager rolls back all its write operations on the database to bring the database back to its original state where it was prior to the execution of the transaction. Transactions in this state are called aborted. The database recovery module can select one of the two operations after a transaction aborts −
    * Re-start the transaction
    * Kill the transaction
* **Committed **− If a transaction executes all its operations successfully, it is said to be committed. All its effects are now permanently established on the database system.


## Concurrency Problems in DBMS Transactions:

When multiple transactions execute concurrently in an uncontrolled or unrestricted manner, then it might lead to several problems. These problems are commonly referred to as concurrency problems in the database environment. The five concurrency problems that can occur in database are:



<p id="gdcalert63" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image63.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert64">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image63.png "image_tooltip")



### 1. Dirty Read Problem- 


```
Reading the data written by an uncommitted transaction is called a dirty read.
```


This read is called as dirty read because-



* There is always a chance that the uncommitted transaction might roll back later.
* Thus, an uncommitted transaction might make other transactions read a value that does not even exist.
* This leads to inconsistency of the database.



<p id="gdcalert64" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image64.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert65">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image64.png "image_tooltip")


Here,



1. T1 reads the value of A.
2. T1 updates the value of A in the buffer.
3. T2 reads the value of A from the buffer.
4. T2 writes the updated value of A.
5. T2 commits.
6. T1 fails in later stages and rolls back.

 

In this example,



* T2 reads the dirty value of A written by the uncommitted transaction T1.
* T1 fails in later stages and roll backs.
* Thus, the value that T2 read now stands to be incorrect.
* Therefore, the database becomes inconsistent.


## 2. Unrepeatable Read Problem- 

This problem occurs when a transaction gets to read unrepeated i.e. different values of the same variable in its different read operations even when it has not updated its value.

 

**Example-**

 



<p id="gdcalert65" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image65.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert66">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image65.png "image_tooltip")


 

Here,



1. T1 reads the value of X (= 10 say).
2. T2 reads the value of X (= 10).
3. T1 updates the value of X (from 10 to 15 say) in the buffer.
4. T2 again reads the value of X (but = 15).

 

In this example,



* T2 gets to read a different value of X in its second reading.
* T2 wonders how the value of X got changed because according to it, it is running in isolation.


## 3. Lost Update Problem-

 

This problem occurs when multiple transactions execute concurrently and updates from one or more transactions get lost.

 

Example-

 



<p id="gdcalert66" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image66.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert67">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image66.png "image_tooltip")


 

Here,



1. T1 reads the value of A (= 10 say).
2. T2 updates the value to A (= 15 say) in the buffer.
3. T2 does blind write A = 25 (write without read) in the buffer.
4. T2 commits.
5. When T1 commits, it writes A = 25 in the database.

 

In this example,



* T1 writes the over written value of X in the database.
* Thus, updates from T1 gets lost.


## Phantom Read Problem- 

This problem occurs when a transaction reads some variable from the buffer and when it reads the same variable later, it finds that the variable does not exist.

 

**Example-**

 



<p id="gdcalert67" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image67.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert68">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image67.png "image_tooltip")


 Here,



1. T1 reads X.
2. T2 reads X.
3. T1 deletes X.
4. T2 tries reading X but does not find it.

 

In this example,



* T2 finds that there does not exist any variable X when it tries reading X again.
* T2 wonders who deleted the variable X because according to it, it is running in isolation.


## Types of Schedules in DBMS

Schedule, as the name suggests, is a process of lining the transactions and executing them one by one. When there are multiple transactions that are running in a concurrent manner and the order of operation is needed to be set so that the operations do not overlap each other, Scheduling is brought into play and the transactions are timed accordingly.



<p id="gdcalert68" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image68.jpg). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert69">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image68.jpg "image_tooltip")




1. **Serial Schedules:**

     \
Schedules in which the transactions are executed non-interleaved, i.e., a serial schedule is one in which no transaction starts until a running transaction has ended are called serial schedules. \
Example: Consider the following schedule involving two transactions T1 and T2.


<table>
  <tr>
   <td>
T1
   </td>
   <td>T2
   </td>
  </tr>
  <tr>
   <td>R(A)
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>W(A)
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>R(B)
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>W(B)
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>R(A)
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>R(B)
   </td>
  </tr>
</table>


 \
where R(A) denotes that a read operation is performed on some data item ‘A’ \
This is a serial schedule since the transactions perform serially in the order_ T1 —> T2_

**2. Non-Serial Schedule:**

This is a type of Scheduling where the operations of multiple transactions are interleaved. This might lead to a rise in the concurrency problem. The transactions are executed in a non-serial manner, keeping the end result correct and the same as the serial schedule. Unlike the serial schedule where one transaction must wait for another to complete all its operation, in the non-serial schedule, the other transaction proceeds without waiting for the previous transaction to complete. This sort of schedule does not provide any benefit of the concurrent transaction. It can be of two types namely, Serializable and Non-Serializable Schedule


    **a.Serializable**: \
This is used to maintain the consistency of the database. It is mainly used in the Non-Serial scheduling to verify whether the scheduling will lead to any inconsistency or not. On the other hand, a serial schedule does not need the serializability because it follows a transaction only when the previous transaction is complete. The non-serial schedule is said to be in a serializable schedule only when it is equivalent to the serial schedules, for an n number of transactions. Since concurrency is allowed in this case thus, multiple transactions can execute concurrently. A serializable schedule helps in improving both resource utilization and CPU throughput. These are of two types:



* **Conflict Serializable:**

        [ \
](https://www.geeksforgeeks.org/conflict-serializability/)A schedule is called conflict serializable if it can be transformed into a serial schedule by swapping non-conflicting operations. Two operations are said to be conflicting if all conditions satisfy:

        * They belong to different transactions
        * They operate on the same data item
        * At Least one of them is a write operation
* **View Serializable:**

         \
A Schedule is called view serializable if it is viewed equal to a serial schedule (no overlapping transactions). A conflict schedule is a view serializable but if the serializability contains blind writes, then the view serializable does not conflict serializable.


    **b. Non-Serializable**:


     \
The non-serializable schedule is divided into two types, Recoverable and Non-recoverable Schedule.

1. **Recoverable Schedule:** \
Schedules in which transactions commit only after all transactions whose changes they read commit are called recoverable schedules. In other words, if some transaction Tj is reading a value updated or written by some other transaction Ti, then the commit of Tj must occur after the commit of Ti.

         \
Example – Consider the following schedule involving two transactions T1 and T2.


<table>
  <tr>
   <td>
T1
   </td>
   <td>T2
   </td>
  </tr>
  <tr>
   <td>R(A)
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>W(A)
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>W(A)
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>R(A)
   </td>
  </tr>
  <tr>
   <td>commit
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>commit
   </td>
  </tr>
</table>




* **Cascading Schedule:**

Also called Avoids cascading aborts/rollbacks (ACA). When there is a failure in one transaction and this leads to the rolling back or aborting other dependent transactions, then such scheduling is referred to as Cascading rollback or cascading abort. Example:



<p id="gdcalert69" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image69.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert70">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image69.png "image_tooltip")




* **Cascadeless Schedule:** \
Schedules in which transactions read values only after all transactions whose changes they are going to read commit are called cascadeless schedules. Avoids that a single transaction abort leads to a series of transaction rollbacks. A strategy to prevent cascading aborts is to disallow a transaction from reading uncommitted changes from another transaction in the same schedule. \
In other words, if some transaction Tj wants to read value updated or written by some other transaction Ti, then the commit of Tj must read it after the commit of Ti. \
Example: Consider the following schedule involving two transactions T1 and T2.

<table>
  <tr>
   <td>
T1
   </td>
   <td>T2
   </td>
  </tr>
  <tr>
   <td>R(A)
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>W(A)
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>W(A)
   </td>
  </tr>
  <tr>
   <td>commit
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>R(A)
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>commit
   </td>
  </tr>
</table>


 \
This schedule is cascadeless. Since the updated value of A is read by T2 only after the updating transaction i.e. T1 commits. \
Example: Consider the following schedule involving two transactions T1 and T2.


<table>
  <tr>
   <td>T1
   </td>
   <td>T2
   </td>
  </tr>
  <tr>
   <td>R(A)
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>W(A)
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>R(A)
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>W(A)
   </td>
  </tr>
  <tr>
   <td>abort
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>abort
   </td>
  </tr>
</table>


 \
It is a recoverable schedule but it does not avoid cascading aborts. It can be seen that if T1 aborts, T2 will have to be aborted too in order to maintain the correctness of the schedule as T2 has already read the uncommitted value written by T1.



* **Strict Schedule:** \
A schedule is strict if for any two transactions Ti, Tj, if a write operation of Ti precedes a conflicting operation of Tj (either read or write), then the commit or abort event of Ti also precedes that conflicting operation of Tj. \
In other words, Tj can read or write updated or written value of Ti only after Ti commits/aborts. \
Example: Consider the following schedule involving two transactions T1 and T2.

<table>
  <tr>
   <td>
T1
   </td>
   <td>T2
   </td>
  </tr>
  <tr>
   <td>R(A)
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>R(A)
   </td>
  </tr>
  <tr>
   <td>W(A)
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>commit
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>W(A)
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>R(A)
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>commit
   </td>
  </tr>
</table>



        This is a strict schedule since T2 reads and writes A which is written by T1 only after the commit of T1.



2. **Non-Recoverable Schedule:**

Example: Consider the following schedule involving two transactions T1 and T2.


<table>
  <tr>
   <td>T1
   </td>
   <td>T2
   </td>
  </tr>
  <tr>
   <td>R(A)
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>W(A)
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>W(A)
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>R(A)
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>commit
   </td>
  </tr>
  <tr>
   <td>abort
   </td>
   <td>
   </td>
  </tr>
</table>


T2 read the value of A written by T1, and committed. T1 later aborted, therefore the value read by T2 is wrong, but since T2 committed, this schedule is non-recoverable.

**Note **– It can be seen that:



* Cascadeless schedules are stricter than recoverable schedules or are a subset of recoverable schedules.
* Strict schedules are stricter than cascadeless schedules or are a subset of cascadeless schedules.
* Serial schedules satisfy constraints of all recoverable, cascadeless and strict schedules and hence is a subset of strict schedules.



<p id="gdcalert70" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image70.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert71">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image70.png "image_tooltip")



## Conflict Serializable Schedule



* A schedule is called conflict serializability if after swapping of non-conflicting operations, it can transform into a serial schedule.
* The schedule will be a conflict serializable if it is conflict equivalent to a serial schedule.

**Conflicting Operations:**

The two operations become conflicting if all conditions satisfy:



1. Both belong to separate transactions.
2. They have the same data item.
3. They contain at least one write operation.

**Example**:

Swapping is possible only if S1 and S2 are logically equal.



<p id="gdcalert71" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image71.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert72">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image71.png "image_tooltip")


Here, S1 = S2. That means it is non-conflict.



<p id="gdcalert72" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image72.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert73">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image72.png "image_tooltip")


Here, S1 ≠ S2. That means it is a conflict.

**Conflict Equivalent**

In the conflict equivalent, one can be transformed to another by swapping non-conflicting operations. In the given example, S2 is conflict equivalent to S1 (S1 can be converted to S2 by swapping non-conflicting operations).

Two schedules are said to be conflict equivalent if and only if:



1. They contain the same set of the transaction.
2. If each pair of conflict operations are ordered in the same way.

**Example:**



<p id="gdcalert73" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image73.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert74">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image73.png "image_tooltip")


Schedule S2 is a serial schedule because, in this, all operations of T1 are performed before starting any operation of T2. Schedule S1 can be transformed into a serial schedule by swapping non-conflicting operations of S1.

After swapping of non-conflict operations, the schedule S1 becomes:


<table>
  <tr>
   <td>T1
   </td>
   <td>T2
   </td>
  </tr>
  <tr>
   <td>Read(A)
<p>
Write(A)
<p>
Read(B)
<p>
Write(B)
   </td>
   <td>Read(A)
<p>
Write(A)
<p>
Read(B)
<p>
Write(B)
   </td>
  </tr>
</table>


Since, S1 is conflict serializable.


## Concurrency Control:

In a multiprogramming environment where multiple transactions can be executed simultaneously, it is highly important to control the concurrency of transactions. We have concurrency control protocols to ensure atomicity, isolation, and serializability of concurrent transactions. Concurrency control protocols can be broadly divided into two categories −



* Lock based protocols
* Timestamp based protocols



1. 
Lock-based Protocols
Database systems equipped with lock-based protocols use a mechanism by which any transaction cannot read or write data until it acquires an appropriate lock on it. Locks are of two kinds −



* **Binary Locks** − A lock on a data item can be in two states; it is either locked or unlocked.
* **Shared/exclusive **− This type of locking mechanism differentiates the locks based on their uses. If a lock is acquired on a data item to perform a write operation, it is an exclusive lock. Allowing more than one transaction to write on the same data item would lead the database into an inconsistent state. Read locks are shared because no data value is being changed.

    There are four types of lock protocols available −

1. **Simplistic Lock Protocol - **Simplistic lock-based protocols allow transactions to obtain a lock on every object before a 'write' operation is performed. Transactions may unlock the data item after completing the ‘write’ operation.
2. **Pre-claiming Lock Protocol - **Pre-claiming protocols evaluate their operations and create a list of data items on which they need locks. Before initiating an execution, the transaction requests the system for all the locks it needs beforehand. If all the locks are granted, the transaction executes and releases all the locks when all its operations are over. If all the locks are not granted, the transaction rolls back and waits until all the locks are granted.

                 

<p id="gdcalert74" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image74.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert75">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image74.png "image_tooltip")




3. **Two-Phase Locking 2PL - **This locking protocol divides the execution phase of a transaction into three parts. In the first part, when the transaction starts executing, it seeks permission for the locks it requires. The second part is where the transaction acquires all the locks. As soon as the transaction releases its first lock, the third phase starts. In this phase, the transaction cannot demand any new locks; it only releases the acquired locks.

                   

<p id="gdcalert75" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image75.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert76">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image75.png "image_tooltip")



        Two-phase locking has two phases, one is growing, where all the locks are being acquired by the transaction; and the second phase is shrinking, where the locks held by the transaction are being released.


        To claim an exclusive (write) lock, a transaction must first acquire a shared (read) lock and then upgrade it to an exclusive lock.



4. **Strict Two-Phase Locking - **The first phase of Strict-2PL is the same as 2PL. After acquiring all the locks in the first phase, the transaction continues to execute normally. But in contrast to 2PL, Strict-2PL does not release a lock after using it. Strict-2PL holds all the locks until the commit point and releases all the locks at a time.

        

<p id="gdcalert76" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image76.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert77">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image76.png "image_tooltip")



    Strict-2PL does not have cascading abort as 2PL does.



### 2. Timestamp Ordering protocol:

[	(Must watch)](https://www.youtube.com/watch?v=h60vaqrXHO8&list=PLxCzCOWd7aiFAN6I8CuViBuCdJgiOkT2Y&index=89)

The timestamp-ordering protocol ensures serializability among transactions in their conflicting read and write operations. This is the responsibility of the protocol system that the conflicting pair of tasks should be executed according to the timestamp values of the transactions.



* The timestamp of transaction Ti is denoted as TS(Ti).
* Read time-stamp of data-item X is denoted by R-timestamp(X).
* Write time-stamp of data-item X is denoted by W-timestamp(X).

Timestamp ordering protocol works as follows −



* **If a transaction Ti issues a read(X) operation −**
    * If TS(Ti) &lt; W-timestamp(X)
        * Operation rejected.
    * If TS(Ti) >= W-timestamp(X)
        * Operation executed.
    * All data-item timestamps updated.
* **If a transaction Ti issues a write(X) operation −**
    * If TS(Ti) &lt; R-timestamp(X)
        * Operation rejected.
    * If TS(Ti) &lt; W-timestamp(X)
        * Operation rejected and Ti rolled back.
    * Otherwise, the operation is executed.

**Thomas' Write Rule**

This rule states if TS(Ti) &lt; W-timestamp(X), then the operation is rejected and** Ti is rolled back.**

Time-stamp ordering rules can be modified to make the schedule view serializable.

Instead of making Ti rolled back, the 'write' operation itself is ignored.



<p id="gdcalert77" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image77.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert78">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image77.png "image_tooltip")



## Indexing in DBMS



* Indexing is used to optimize the performance of a database by minimizing the number of disk accesses required when a query is processed.
* The index is a type of data structure. It is used to locate and access the data in a database table quickly.


### Index structure:

Indexes can be created using some database columns.



<p id="gdcalert78" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image78.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert79">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image78.png "image_tooltip")




* The first column of the database is the search key that contains a copy of the primary key or candidate key of the table. The values of the primary key are stored in sorted order so that the corresponding data can be accessed easily.
* The second column of the database is the data reference. It contains a set of pointers holding the address of the disk block where the value of the particular key can be found.


### Indexing Methods



<p id="gdcalert79" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image79.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert80">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image79.png "image_tooltip")



### Ordered indices

The indices are usually sorted to make searching faster. The indices which are sorted are known as ordered indices.

**Example**: Suppose we have an employee table with thousands of record and each of which is 10 bytes long. If their IDs start with 1, 2, 3....and so on and we have to search student with ID-543.



* In the case of a database with no index, we have to search the disk block from starting till it reaches 543. The DBMS will read the record after reading 543*10=5430 bytes.
* In the case of an index, we will search using indexes and the DBMS will read the record after reading 542*2= 1084 bytes which are very less compared to the previous case.


### Primary Index



* If the index is created on the basis of the primary key of the table, then it is known as primary indexing. These primary keys are unique to each record and contain 1:1 relation between the records.
* As primary keys are stored in sorted order, the performance of the searching operation is quite efficient.
* The primary index can be classified into two types: Dense index and Sparse index.


### Dense index



* The dense index contains an index record for every search key value in the data file. It makes searching faster.
* In this, the number of records in the index table is same as the number of records in the main table.
* It needs more space to store index record itself. The index records have the search key and a pointer to the actual record on the disk.



<p id="gdcalert80" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image80.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert81">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image80.png "image_tooltip")



### Sparse index



* In the data file, index record appears only for a few items. Each item points to a block.
* In this, instead of pointing to each record in the main table, the index points to the records in the main table in a gap.



<p id="gdcalert81" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image81.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert82">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image81.png "image_tooltip")



## Clustering Index



* A clustered index can be defined as an ordered data file. Sometimes the index is created on non-primary key columns which may not be unique for each record.
* In this case, to identify the record faster, we will group two or more columns to get the unique value and create index out of them. This method is called a clustering index.
* The records which have similar characteristics are grouped, and indexes are created for these group.

**Example**: suppose a company contains several employees in each department. Suppose we use a clustering index, where all employees which belong to the same Dept_ID are considered within a single cluster, and index pointers point to the cluster as a whole. Here Dept_Id is a non-unique key.



<p id="gdcalert82" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image82.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert83">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image82.png "image_tooltip")


The previous schema is little confusing because one disk block is shared by records which belong to the different cluster. If we use separate disk block for separate clusters, then it is called better technique.



<p id="gdcalert83" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image83.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert84">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image83.png "image_tooltip")



### Secondary Index

In the sparse indexing, as the size of the table grows, the size of mapping also grows. These mappings are usually kept in the primary memory so that address fetch should be faster. Then the secondary memory searches the actual data based on the address got from mapping. If the mapping size grows then fetching the address itself becomes slower. In this case, the sparse index will not be efficient. To overcome this problem, secondary indexing is introduced.

In secondary indexing, to reduce the size of mapping, another level of indexing is introduced. In this method, the huge range for the columns is selected initially so that the mapping size of the first level becomes small. Then each range is further divided into smaller ranges. The mapping of the first level is stored in the primary memory, so that address fetch is faster. The mapping of the second level and actual data are stored in the secondary memory (hard disk).



<p id="gdcalert84" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image84.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert85">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image84.png "image_tooltip")


**For example:**



* If you want to find the record of roll 111 in the diagram, then it will search the highest entry which is smaller than or equal to 111 in the first level index. It will get 100 at this level.
* Then in the second index level, again it does max (111) &lt;= 111 and gets 110. Now using the address 110, it goes to the data block and starts searching each record till it gets 111.
* This is how a search is performed in this method. Inserting, updating or deleting is also done in the same manner.

    ```
B Tree
B Tree is a specialized m-way tree that can be widely used for disk access. A B-Tree of order m can have at most m-1 keys and m children. One of the main reason of using B tree is its capability to store large number of keys in a single node and large key values by keeping the height of the tree relatively small.

A B tree of order m contains all the properties of an M way tree. In addition, it contains the following properties.

Every node in a B-Tree contains at most m children.
Every node in a B-Tree except the root node and the leaf node contain at least m/2 children.
The root nodes must have at least 2 nodes.
All leaf nodes must be at the same level.

It is not necessary that, all the nodes contain the same number of children but, each node must have m/2 number of nodes.

A B tree of order 4 is shown in the following image.

While performing some operations on B Tree, any property of B Tree may violate such as number of minimum children a node can have. To maintain the properties of B Tree, the tree may split or join.
Operations
Searching :
Searching in B Trees is similar to that in Binary search tree. For example, if we search for an item 49 in the following B Tree. The process will something like following :
Compare item 49 with root node 78. since 49 < 78 hence, move to its left sub-tree.
Since, 40<49<56, traverse right sub-tree of 40.
49>45, move to right. Compare 49.
match found, return.

Searching in a B tree depends upon the height of the tree. The search algorithm takes O(log n) time to search any element in a B tree.

Inserting
Insertions are done at the leaf node level. The following algorithm needs to be followed in order to insert an item into B Tree.

Traverse the B Tree in order to find the appropriate leaf node at which the node can be inserted.
If the leaf node contain less than m-1 keys then insert the element in the increasing order.
Else, if the leaf node contains m-1 keys, then follow the following steps.
Insert the new element in the increasing order of elements.
Split the node into the two nodes at the median.
Push the median element upto its parent node.
If the parent node also contain m-1 number of keys, then split it too by following the same steps.

Example:

Insert the node 8 into the B Tree of order 5 shown in the following image.

8 will be inserted to the right of 5, therefore insert 8.


The node, now contain 5 keys which is greater than (5 -1 = 4 ) keys. Therefore split the node from the median i.e. 8 and push it up to its parent node shown as follows.


Deletion
Deletion is also performed at the leaf nodes. The node which is to be deleted can either be a leaf node or an internal node. Following algorithm needs to be followed in order to delete a node from a B tree.

Locate the leaf node.

If there are more than m/2 keys in the leaf node then delete the desired key from the node.

If the leaf node doesn't contain m/2 keys then complete the keys by taking the element from eight or left sibling.
If the left sibling contains more than m/2 elements then push its largest element up to its parent and move the intervening element down to the node where the key is deleted.

If the right sibling contains more than m/2 elements then push its smallest element up to the parent and move intervening element down to the node where the key is deleted.

If neither of the sibling contain more than m/2 elements then create a new leaf node by joining two leaf nodes and the intervening element of the parent node.

If parent is left with less than m/2 nodes then, apply the above process on the parent too.

If the the node which is to be deleted is an internal node, then replace the node with its in-order successor or predecessor. Since, successor or predecessor will always be on the leaf node hence, the process will be similar as the node is being deleted from the leaf node.

Example 1
Delete the node 53 from the B Tree of order 5 shown in the following figure.


53 is present in the right child of element 49. Delete it.



Now, 57 is the only element which is left in the node, the minimum number of elements that must be present in a B tree of order 5, is 2. it is less than that, the elements in its left and right sub-tree are also not sufficient therefore, merge it with the left sibling and intervening element of parent i.e. 49.
The final B tree is shown as follows.


Application of B tree
B tree is used to index the data and provides fast access to the actual data stored on the disks since, the access to value stored in a large database that is stored on a disk is a very time consuming process.
Searching an un-indexed and unsorted database containing n key values needs O(n) running time in worst case. However, if we use B Tree to index this database, it will be searched in O(log n) time in worst case.

```




## B+ Tree



* The B+ tree is a balanced binary search tree. It follows a multi-level index format.
* In the B+ tree, leaf nodes denote actual data pointers. B+ tree ensures that all leaf nodes remain at the same height.
* In the B+ tree, the leaf nodes are linked using a link list. Therefore, a B+ tree can support random access as well as sequential access.


### Structure of B+ Tree



* In the B+ tree, every leaf node is at equal distance from the root node. The B+ tree is of the order n where n is fixed for every B+ tree.
* It contains an internal node and leaf node.



<p id="gdcalert85" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image85.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert86">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image85.png "image_tooltip")


**Internal node**



* An internal node of the B+ tree can contain at least n/2 record pointers except the root node.
* At most, an internal node of the tree contains n pointers.

**Leaf node**



* The leaf node of the B+ tree can contain at least n/2 record pointers and n/2 key values.
* At most, a leaf node contains n record pointer and n key values.
* Every leaf node of the B+ tree contains one block pointer P to point to the next leaf node.


### Searching a record in B+ Tree

Suppose we have to search 55 in the below B+ tree structure. First, we will fetch for the intermediary node which will direct to the leaf node that can contain a record for 55.

So, in the intermediary node, we will find a branch between 50 and 75 nodes. Then at the end, we will be redirected to the third leaf node. Here DBMS will perform a sequential search to find 55.



<p id="gdcalert86" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image86.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert87">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image86.png "image_tooltip")



### B+ Tree Insertion

Suppose we want to insert a record 60 in the below structure. It will go to the 3rd leaf node after 55. It is a balanced tree, and a leaf node of this tree is already full, so we cannot insert 60 there.

In this case, we have to split the leaf node, so that it can be inserted into tree without affecting the fill factor, balance and order.



<p id="gdcalert87" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image87.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert88">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image87.png "image_tooltip")


The 3<sup>rd</sup> leaf node has the values (50, 55, 60, 65, 70) and its current root node is 50. We will split the leaf node of the tree in the middle so that its balance is not altered. So we can group (50, 55) and (60, 65, 70) into 2 leaf nodes.

If these two has to be leaf nodes, the intermediate node cannot branch from 50. It should have 60 added to it, and then we can have pointers to a new leaf node.



<p id="gdcalert88" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image88.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert89">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image88.png "image_tooltip")


This is how we can insert an entry when there is overflow. In a normal scenario, it is very easy to find the node where it fits and then place it in that leaf node.


### B+ Tree Deletion

Suppose we want to delete 60 from the above example. In this case, we have to remove 60 from the intermediate node as well as from the 4th leaf node too. If we remove it from the intermediate node, then the tree will not satisfy the rule of the B+ tree. So we need to modify it to have a balanced tree.

After deleting node 60 from above B+ tree and re-arranging the nodes, it will show as follows:



<p id="gdcalert89" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image89.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert90">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image89.png "image_tooltip")

